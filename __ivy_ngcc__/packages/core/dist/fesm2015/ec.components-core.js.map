{"version":3,"sources":["/Users/felix/entrecode/ec.components/packages/core/dist/fesm2015/ec.components-core.js"],"names":[],"mappings":"AAAA","file":"ec.components-core.js","sourcesContent":["import { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\n/**\n * A Collection is a more sophisticated Array. It is fundamental for other classes like List.\n */\nclass Collection {\n    /**\n     * Constructs the collection with the given item Array (optional).\n     * @example\n     * ```typescript\n     *  const numbers = new Collection([1, 2, 3]);\n     * ```\n     */\n    constructor(items = []) {\n        /** Subject that is nexted when the items update */\n        this.update = new Subject();\n        /** Subject that is nexted when the items change */\n        this.update$ = this.update.asObservable();\n        this.items = [];\n        items.forEach((item) => {\n            this.items.push(item);\n        });\n    }\n    /** Returns the index of the given item */\n    index(item) {\n        return this.items.indexOf(item);\n    }\n    /**\n     * Checks if the Collection contains the given item.\n     * @example\n     * ```typescript\n     * numbers.has(2); //true\n     * ```\n     */\n    has(item) {\n        return this.index(item) !== -1;\n    }\n    /**\n     * Checks if the Collection contains all given items.\n     * @example\n     * ```typescript\n     * numbers.has([1,2]); //true\n     * ```\n     */\n    hasAll(items = []) {\n        if (items === null) {\n            // console.warn('has all fail', this, items);\n            return false;\n        }\n        return items.reduce((has, item) => {\n            return has && this.has(item);\n        }, true);\n    }\n    /**\n     * Adds the given item to the Collection. If the unique flag is set, the item will only be added\n     * if it is not contained.\n     * @example\n     * ```typescript\n     * numbers.add(4);\n     * ```\n     */\n    add(item, unique, event = true) {\n        if (unique && this.has(item)) {\n            return false;\n        }\n        this.items.push(item);\n        if (event) {\n            this.update.next(this);\n        }\n    }\n    /**\n     * Adds the given items to the Collection. If the unique flag is set, only items that are not\n     * contained will be added.\n     * @example\n     * ```typescript\n     * numbers.addAll([5, 6, 7]);\n     * ```\n     */\n    addAll(items = [], unique = false, event = true) {\n        const length = this.items.length;\n        items.forEach((item) => {\n            this.add(item, unique, false);\n        });\n        if (this.items.length > length && event) {\n            this.update.next(this);\n        }\n    }\n    /**\n     * Removes the given item from the Collection.\n     * @example\n     * ```typescript\n     * numbers.remove(4);\n     * ```\n     */\n    remove(item, event = true) {\n        if (!this.has(item)) {\n            return false;\n        }\n        this.items.splice(this.index(item), 1);\n        if (event) {\n            this.update.next(this);\n        }\n    }\n    /**\n     * Removes all items from the Collection.\n     * @example\n     * ```typescript\n     * numbers.removeAll();\n     * ```\n     */\n    removeAll(items, event = true) {\n        const length = this.items.length;\n        if (items) {\n            items.forEach((item) => {\n                this.remove(item, false);\n            });\n        }\n        else {\n            this.items.length = 0;\n        }\n        if (this.items.length < length && event) {\n            this.update.next(this);\n        }\n    }\n    /** Toggles the item in and out of collection */\n    toggle(item, event = true) {\n        if (this.has(item)) {\n            this.remove(item, event);\n        }\n        else {\n            this.add(item, event);\n        }\n    }\n    /** Replaces all current items with the given items. */\n    replaceWith(items, event = true) {\n        if (this.items && this.items.length) {\n            this.removeAll(undefined, false);\n        }\n        if (items.length) {\n            this.addAll(items, false, false);\n        }\n        if (event) {\n            this.update.next(this);\n        }\n    }\n    /** Returns true if the collection is empty */\n    isEmpty() {\n        return this.items.length === 0;\n    }\n    /** Moves the given item to the given array index. */\n    move(item, index, event = true) {\n        if (!this.has(item) || this.items.indexOf(item) === index) {\n            return;\n        }\n        this.items.splice(index, 0, this.items.splice(this.items.indexOf(item), 1)[0]);\n        if (event) {\n            this.update.next(this);\n        }\n    }\n}\n\n/** A Field acts as a property of an Item. It holds a single Property config. */\nclass Field {\n    /** A Field is constructed by assigning the given config and the property to itself*/\n    constructor(property, config) {\n        /** Possible Values e.g. in a select */\n        this.values = [];\n        /** Class string */\n        this.class = '';\n        if (config) {\n            Object.assign(this, config);\n        }\n        Object.assign(this, { property: property });\n        this.id = `${this.property}_${Date.now()}`;\n    }\n    /** Returns placeholder if any */\n    getPlaceholder() {\n        return this.placeholder || this.label || this.property;\n    }\n    /** Returns the fields label */\n    getLabel() {\n        if (this.label === false) {\n            return '';\n        }\n        return this.label || this.property;\n    }\n    /** Returns the view for the given occasion */\n    getView(occasion) {\n        return this[occasion + 'View'] || this.view;\n    }\n    /** Returns the component for the given occasion */\n    getComponent(occasion) {\n        return this[occasion + 'Component'];\n    }\n}\n\n/** The Root class for all Configurations. */\nclass Config {\n    constructor() {\n        // TODO use Map !!!! (like simi did in EventEmitter.ts)\n        /** The config object. */\n        this.config = {};\n    }\n    /** This method is a getter and setter for configurations. The key stands for the config (e.g. model).\n     * The property is a sub property if the config (e.g. fields => model.fields).\n     * If no config is given, the method just returns the configuration for the given property.\n     * If a config is given, the property config is merged via Object.assign. */\n    configure(key, property, config) {\n        if (!this.config[key]) {\n            this.config[key] = {};\n        }\n        if (!config) {\n            return this.config[key][property];\n        }\n        if (!this.config[key][property]) {\n            this.config[key][property] = {};\n        }\n        Object.assign(this.config[key][property], config);\n        return this;\n    }\n}\n\n/** An Item basically wraps an Object and provides a config with metadata and helper methods to access the object. */\nclass Item {\n    /** Each item is constructed with its body and an optional config. */\n    constructor(body, config = {}) {\n        this.body = body;\n        this.config = config || this.generateConfig();\n    }\n    /** Generates a config from the body by setting view to the properties type. */\n    generateConfig() {\n        const config = { fields: {} };\n        if (this.body === undefined) {\n            return config;\n        }\n        this.getProperties().forEach((property) => {\n            config.fields[property] = {\n                view: typeof this.body[property],\n                type: typeof this.body[property],\n            };\n            if (config.fields[property].view === 'object' && Array.isArray(this.body[property])) {\n                config.fields[property].view = 'array';\n                config.fields[property].values = this.body[property];\n                // config.fields[property].solo = true;\n            }\n        });\n        return config;\n    }\n    /** Returns the item's body */\n    getBody() {\n        return this.body;\n    }\n    /** Returns true if the body is defined and not null*/\n    hasBody() {\n        return this.body !== undefined && this.body !== null;\n    }\n    /** deletes the item body */\n    clear() {\n        delete this.body;\n    }\n    /** Assigns the given config to the existing via Object.assign */\n    useConfig(config) {\n        this.config = Object.assign(this.config, config);\n    }\n    /** Returns the item's config */\n    getConfig() {\n        return this.config;\n    }\n    /** Returns an Array of properties possessed by the body. */\n    getProperties() {\n        if (!this.body || typeof this.body !== 'object') {\n            if (typeof this.body !== 'object') {\n                return [this.config && this.config.title ? this.config.title : 'body'];\n            }\n            return [];\n        }\n        return Object.keys(this.body);\n    }\n    /** Returns the value of the the Item's identifier property. */\n    id() {\n        if (!this.config.identifier) {\n            throw new Error('cannot get id of item without identifier!');\n        }\n        return this.resolve(this.config.identifier);\n    }\n    /** Returns either the whole body (if no property is given) or the value of the given property.\n     * This method will traverse the body via the config.resolve function (if given). */\n    resolve(property) {\n        if (!this.hasBody()) {\n            return;\n        }\n        if (typeof this.body !== 'object') {\n            return this.body;\n        }\n        if (!this.config) {\n            return property ? this.body[property] : this.body;\n        }\n        if (!property) {\n            if (this.config.resolve) {\n                return this.config.resolve(this.body, this);\n            }\n            return this.body;\n        }\n        if (this.config.fields && this.config.fields[property] && this.config.fields[property].resolve) {\n            return this.config.fields[property].resolve(this.body, this, property);\n        }\n        if (!this.config.resolve) {\n            return this.body[property];\n        }\n        const v = this.config.resolve(this.body, this);\n        return v ? v[property] : null;\n    }\n    /** Resolves the given path on the item object. e.g. \"value.config.usePassword\" will resolve that object path, if existing. */\n    resolvePath(path) {\n        return getPath(this.body, path);\n    }\n    /** The main method for transformation functions like resolve, display and group.\n     * If you dont set the third parameter, the current item value will be used.\n     * The third parameter can be used to transform a value that is not yet possesed (e.g. to\n     * serialize) */\n    transform(action, property, value = this.resolve(property), defaultValue = this.resolve(property)) {\n        if (!this.hasBody()) {\n            return;\n        }\n        if (this.config.fields && this.config.fields[property] && this.config.fields[property][action]) {\n            return this.config.fields[property][action](value, this.body, property);\n        }\n        return defaultValue;\n    }\n    /** Returns the output of the config.group transformation function with the given property value.\n     * If no group function is set, it will just return the property value.*/\n    group(property) {\n        return this.transform('group', property);\n    }\n    /** If no property given: Returns the output of the config.classes method or ''.\n     * If property given: Returns the output of the config.fields[property].classes method or '' */\n    classes(property) {\n        if (property) {\n            return this.transform('classes', property, this.resolve(property), '') || '';\n        }\n        if (!this.config || !this.config.classes) {\n            return '';\n        }\n        return this.config.classes(this);\n    }\n    /** Returns the output of the config.display transformation function with the given property value.\n     * If no display function is set, it will just return the property value.*/\n    display(property) {\n        if (!property) {\n            return this.transform('display', this.config.label || this.getProperties()[0]); // Object.keys(this.resolve())[0]\n        }\n        return this.transform('display', property);\n    }\n    /** Transforms the given field's value for sorting */\n    sort(property) {\n        return this.transform('sort', property);\n    }\n    /** Returns value with all readOnly properties removed */\n    pickWriteOnly(value = this.body) {\n        return Object.assign({}, ...Object.keys(value)\n            .map((property) => {\n            if (this.config.fields[property].readOnly) {\n                return;\n            }\n            return { [property]: value[property] };\n        })\n            .filter((v) => !!v));\n    }\n    isImmutableProperty(property) {\n        if (this.config &&\n            this.config.fields &&\n            this.config.fields[property] &&\n            typeof this.config.fields[property].immutable === 'function') {\n            return this.config.fields[property].immutable(this);\n        }\n        return this.config.fields[property].immutable;\n    }\n    deleteImmutableProperties(value = this.body) {\n        Object.keys(this.config.fields).forEach((property) => {\n            if (value.hasOwnProperty(property) && this.isImmutableProperty(property)) {\n                delete value[property];\n            }\n        });\n    }\n    /** Transforms the given field's value for serialization when saving. */\n    serialize(value, put = false) {\n        if (put) {\n            value = this.pickWriteOnly(value);\n        }\n        this.deleteImmutableProperties(value);\n        /** Run the remaining properties through serializers */\n        Object.keys(value).map((property) => {\n            Object.assign(value, {\n                [property]: this.transform('serialize', property, value[property]),\n            });\n        });\n        return value;\n        /** Run the remaining properties through serializers */\n        /*return Object.keys(value).reduce((serialized, property) => {\n          return Object.assign(serialized, {\n            [property]: this.transform('serialize', property, value[property])\n          });\n        }, {});*/\n    }\n    /** Saves the given value. Run serializers before assigning the new value. */\n    save(value = this.body) {\n        if (this.config.onSave) {\n            return new Promise((resolve, reject) => {\n                try {\n                    Promise.resolve(this.config.onSave(this, value)).then((_value) => {\n                        this.body = _value;\n                        resolve(this);\n                    }).catch(error => reject(error));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            });\n        }\n        this.body = Object.assign(this.resolve() || {}, value);\n        return Promise.resolve(this);\n    }\n    /** Action method that is meant to be called on a button click or similar.\n     * Calls the config#action method with the item and the property name */\n    action(property, e) {\n        e.preventDefault();\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n        if (this.config.fields[property].action) {\n            this.config.fields[property].action(this, property);\n        }\n    }\n}\nfunction getPath(o, path) {\n    const p = path.split('.');\n    return p.length === 1 ? (o || {})[p[0]] : getPath((o || {})[p[0]], p.slice(1).join('.'));\n}\n\n/** A Form is an extension of an Item. In advance to an Item it will create an Array of fields that is either extracted\n * from config.fields or directly from the item body. */\n/** The Form class is an Item with additional info about its properties (Fields). */\nclass Form extends Item {\n    /** The constructor will populate the fields array.\n     * If config.fields is set only the configured fields will be created.\n     * If not, all properties of the given body will be used as fields. */\n    constructor(body, config) {\n        super(body, config);\n        this.fields = [];\n        if (!this.config || !this.config.fields) {\n            return;\n        }\n        Object.keys(this.config.fields).forEach((property) => {\n            this.fields.push(new Field(property, this.config.fields[property]));\n        });\n    }\n    /** creates and adds a single field to the form */\n    createField(property, config) {\n        if (!config) {\n            return;\n        }\n        if (!property) {\n            return;\n        }\n        if (this.config.fields[property]) {\n            console.error('cannot create field \"', property, '\". Property name already taken.');\n            return;\n        }\n        this.config.fields[property] = config;\n        const field = new Field(property, this.config.fields[property]);\n        this.fields = this.fields.concat([field]);\n        return field;\n    }\n    /** returns the field instance of the given property */\n    getField(property) {\n        return this.fields.find((field) => field.property === property);\n    }\n    /** Returns the original value of the property, if any. */\n    getValue(property) {\n        if (!this.body && this.config.fields && this.config.fields[property]) {\n            // If the prefill is not a primitive, return a clone to stay pristine\n            if (Array.isArray(this.config.fields[property].prefill)) {\n                return this.config.fields[property].prefill.slice(0);\n            }\n            else if (typeof this.config.fields[property].prefill === 'object') {\n                return Object.assign({}, this.config.fields[property].prefill);\n            }\n            // if no body is present, the prefills are used\n            return this.config.fields[property].prefill;\n        }\n        else {\n            return this.resolve(property);\n        }\n    }\n    /** Returns true if the form is currently in edit mode (has a body set) */\n    isEditing() {\n        return !!this.getBody();\n    }\n    /** Returns true if the form is currently in create mode (has not a body set) */\n    isCreating() {\n        return !this.isEditing();\n    }\n}\n\n/** This class can be used to control the loading behaviour of external data. */\nclass Pagination {\n    /** You can init each Pagination instance with an optional config.\n     * If no config is provided, it will default to ```{page: 1, size: 25}```. */\n    constructor(config, total) {\n        /** Subject for tracking changes. */\n        this.change = new Subject();\n        /** Observable that is nexted when the pagination has changed. */\n        this.change$ = this.change.asObservable();\n        this.config = { page: 1, size: 25 };\n        Object.assign(this.config, config);\n        Object.assign(this.config, {\n            availableSizes: Array.from(new Set([this.config.size]\n                .concat(this.config.availableSizes || [10, 25, 50, 100], [this.config.size])\n                .sort((a, b) => a - b))),\n        });\n        if (total) {\n            this.setTotal(total);\n        }\n    }\n    /** Retrieves the current page */\n    getPage() {\n        return this.config.page;\n    }\n    /** Retrieves the number of pages */\n    getPages() {\n        return this.pages ? this.pages.length : 0;\n    }\n    /** Loads the next page. Throws error if already on last page. */\n    next() {\n        if (this.isLast()) {\n            return; // already last page\n        }\n        this.config.page += 1;\n        this.load();\n    }\n    /** Loads the previous page. Throws error if already on first page. */\n    prev() {\n        if (this.isFirst()) {\n            return; // already first page\n        }\n        this.config.page -= 1;\n        this.load();\n    }\n    /**\n     * Sets the total number of items and calculcates the page count.\n     * */\n    setTotal(total) {\n        /* if (this.total !== total) {\n          this.change.next(this.config);\n        } */\n        this.total = total;\n        this.pages = new Array(Math.ceil(this.total / this.config.size));\n        if (this.config.page !== 1 && this.config.page > this.pages.length) {\n            this.config.page = this.pages.length || 1;\n            this.load();\n        }\n    }\n    /** Merges config and fires next on change */\n    load(config) {\n        if (config) {\n            Object.assign(this.config, config);\n        }\n        this.change.next(this.config);\n    }\n    /** Selects the given page number */\n    select(page, silent = false) {\n        if (page === this.config.page || silent) {\n            this.config.page = page;\n            return;\n        }\n        this.load({ page: page });\n    }\n    /** Loads the first Page */\n    first() {\n        this.load({ page: 1 });\n    }\n    /** Loads the last page */\n    last() {\n        if (!this.pages) {\n            throw new Error(`Cannot load last page without knowing the item count.\n        Call setTotal(itemCount) before loading.`);\n        }\n        this.load({ page: this.pages.length });\n    }\n    /** Returns true if the given page number is currently active.*/\n    isActive(page) {\n        return this.config.page === page;\n    }\n    /** Returns true if the current page is the first one */\n    isFirst() {\n        return this.config.page === 1;\n    }\n    /** Returns true if the current page is the last one */\n    isLast() {\n        if (!this.pages) {\n            return true;\n        }\n        return this.config.page === this.pages.length;\n    }\n    /** slices a given array according to the current pagination state */\n    slice(items) {\n        return items.slice((this.config.page - 1) * this.config.size, this.config.page * this.config.size);\n    }\n    /** Returns an object with all relevant infos about the current state of pagination */\n    params() {\n        return {\n            page: this.getPage(),\n            pages: this.getPages(),\n            total: this.total,\n            from: (this.getPage() - 1) * this.config.size + 1,\n            to: Math.min(this.getPage() * this.config.size, this.total),\n            size: this.config.size,\n            availableSizes: this.config.availableSizes,\n        };\n    }\n    /** updates the size of the pages.  */\n    updateSize(size) {\n        if (!size) {\n            return;\n        }\n        this.load({ size, page: 1 });\n    }\n}\n\n/** Used for natural sorting of strings */\nconst collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\n/** Sorts strings (naturally) */\nfunction sortString(a, b) {\n    return collator.compare(a, b);\n}\n/** Sorts numbers */\nfunction sortNumber(a, b) {\n    return a - b;\n}\n/** Sorts booleans */\nfunction sortBoolean(a, b) {\n    return a ? -1 : 1;\n}\n/** The Sorter is a singleton that handles all kinds of sorting operations. */\nclass Sorter {\n    /** Returns the sorting algorithm for the given item array. */\n    static getAlgorithm(items, property) {\n        if (!items.length) {\n            return;\n        }\n        if (property && !items.reduce((has, item) => has && item.sort(property) !== undefined, true)) {\n            console.warn('cannot sort property \"' + property + '\" because not all items have that property', items);\n            return;\n        }\n        const types = items\n            .map((item) => typeof item.sort(property))\n            .filter((item, index, _items) => _items.indexOf(item) === index);\n        if (types.length > 1) {\n            console.warn('cannot sort items because they contain multiple types:', types);\n            return;\n        }\n        if (!this.sortType[types[0]]) {\n            console.warn('cannot sort items because no algorithm was found for type', types[0]);\n            return;\n        }\n        return this.sortType[types[0]];\n    }\n    /** Sorts a given Array of items after a given property.\n     * @param items Array of arbitrary content.\n     * @param property Optional property to sort after (For Objects)\n     * @param desc Optional Flag that will reverse sort the result (descending).\n     * @param resolve Optional resolve function to expose relevant the part of object that contains\n     *   the given property. */\n    static sort(items, property, desc) {\n        const algorithm = this.getAlgorithm(items, property);\n        if (!algorithm) {\n            return;\n        }\n        items.sort((a, b) => {\n            if (!property) {\n                return algorithm(a.resolve(), b.resolve());\n            }\n            return algorithm(a.sort(property), b.sort(property));\n        });\n        if (desc) {\n            items.reverse();\n        }\n    }\n}\n/** Contains sorting methods for different value types. */\nSorter.sortType = {\n    string: sortString,\n    number: sortNumber,\n    boolean: sortBoolean,\n};\n\n/**\n * A more sophisticated Collection of Objects with arbitrary content.\n * It comes with features like resolve functions, identifiers, display formatting and sorting.\n */\nclass List extends Collection {\n    /**\n     * Constructs the List. Populates the items and instantiates the fields.\n     */\n    constructor(values, config = {}, pagination) {\n        super([]);\n        /**\n         * Current Value Groups (Different Unique Values).\n         */\n        this.groups = [];\n        /** The items of the current page */\n        this.page = [];\n        /** Subject that should be nexted when loading is finished */\n        this.change = new Subject();\n        /** Observable that is nexted when the list has changed. */\n        this.change$ = this.change.asObservable();\n        if (values) {\n            super.addAll(values.map((value) => new Item(value, Object.assign({}, config))), false, false);\n        }\n        this.config = Object.assign({ page: 1, maxColumns: 8 }, config || {});\n        this.fields = this.getFields();\n        this.hideOverflowFields();\n        this.pagination = pagination || new Pagination(this.config, this.items.length);\n        this.change$.subscribe(() => {\n            this.pagination.select(this.config.page || 1, true);\n        });\n        if (!pagination) {\n            // load if no custom pagination was given\n            this.pagination.change$.pipe(debounceTime(200)).subscribe((_config) => this.load(_config));\n            this.load();\n        }\n    }\n    /** Getter for items, calls transform */\n    get display() {\n        if (!this.config || !this.config.display) {\n            return this.items;\n        }\n        return this.config.display(this.items);\n    }\n    /** Loads the list page with the given config or, if none given, uses the current config.\n     * Reapplies grouping (if any) and calls the change Subject. */\n    load(config) {\n        if (config) {\n            Object.assign(this.config, config);\n        }\n        this.page = this.pagination.slice(this.items);\n        this.groupBy(this.config.sortBy);\n        this.change.next(this);\n    }\n    /** Adds the given item to the list and assigns the list config to the item*/\n    add(item, unique, event = true) {\n        item.useConfig(this.config);\n        return super.add(item, unique, event);\n    }\n    /**\n     * Distills Array of item properties. Either uses keys of config.fields or parses the item\n     * properties directly.\n     */\n    getFields() {\n        if (this.config && this.config.fields) {\n            return Object.keys(this.config.fields)\n                .filter((key) => this.config.fields[key].list !== false)\n                .map((field) => new Field(field, this.config.fields[field]));\n        }\n        const fields = [];\n        this.items.forEach((item) => {\n            item.getProperties().forEach((property) => {\n                if (!fields.find((f) => f.property === property)) {\n                    fields.push(new Field(property, { type: typeof item.resolve(property) }));\n                }\n            });\n        });\n        return fields;\n    }\n    toggleVisibility(field) {\n        field.hideInList = !field.hideInList;\n        this.change.next(this);\n    }\n    /** Sets all fields that exceed the maxColumns to hidden */\n    hideOverflowFields() {\n        if (this.config && this.config.maxColumns) {\n            this.fields\n                .filter((f) => !f.hideInList)\n                .forEach((field, index) => {\n                if (index >= this.config.maxColumns && field.hideInList === undefined) {\n                    field.hideInList = true;\n                }\n            });\n        }\n    }\n    /**\n     * Resolves the item with the given Array index or identifier (if configured)\n     */\n    id(identifier) {\n        if (identifier === undefined) {\n            throw new Error(`cannot get item with identifier \"${identifier}\"`);\n        }\n        return (this.items.find((item, key) => {\n            if (!item.config.identifier) {\n                return false;\n            }\n            return item.id() === identifier;\n        }) || this.items[identifier]);\n    }\n    /** Filters the list after the given property and value */\n    filter(property, value = '', operator = 'exact') {\n        this.config.filter = { [property]: value };\n        if (value === null) {\n            this.load();\n            return;\n            // this.page = [].concat(this.items);\n        }\n        // TODO find way to filter with pagination and without loosing filtered out items\n        this.page = this.items\n            .filter((item) => {\n            return item\n                .resolve(property)\n                .toLowerCase()\n                .includes(value.toLowerCase()); // TODO: better filter\n        })\n            .slice(0, this.config.size || 100);\n    }\n    setFilter(filterOptions = {}) {\n        if (!this.isFiltered(null, filterOptions) && !this.isFiltered()) {\n            return;\n        }\n        if (this.isEmptyFilter(filterOptions)) {\n            return this.clearFilter();\n        }\n        filterOptions = Object.keys(filterOptions).reduce((filtered, key) => {\n            if (this.isEmptyFilter(filterOptions[key])) {\n                delete filtered[key];\n            }\n            return filtered;\n        }, filterOptions);\n        this.load({\n            page: 1,\n            filter: filterOptions,\n        });\n    }\n    /** Clears the filter for given property or all properties if none given. */\n    clearFilter(property) {\n        if (property) {\n            return this.filter(property, null);\n        }\n        this.load({\n            page: 1,\n            filter: {},\n        });\n    }\n    /** Helper function. Returns true if the given query value is empty (also recognizes empty array) */\n    isEmptyFilter(query) {\n        return (query === '' ||\n            query === null ||\n            query === undefined ||\n            (Array.isArray(query) && !query.length) ||\n            (typeof query === 'object' && Object.keys(query).length === 0));\n    }\n    /** Returns true if the given property has a filter set. If no property is given it returns true when no property has a filter. */\n    isFiltered(property, filterOptions = this.config.filter) {\n        if (!filterOptions) {\n            return false;\n        }\n        if (!property) {\n            return Object.keys(filterOptions).filter((key) => !this.isEmptyFilter(filterOptions[key])).length > 0;\n        }\n        return !this.isEmptyFilter(filterOptions[property]);\n    }\n    /** Returns the filter */\n    getFilterValue(property, filterOptions = this.config.filter) {\n        if (!property) {\n            property = this.config.label;\n        }\n        if (!filterOptions || !property) {\n            return undefined;\n        }\n        return filterOptions[property];\n    }\n    /** Changes the config's sort variables to reflect the given sorting */\n    sortProperty(property, desc) {\n        if (desc !== undefined) {\n            if (this.config.desc === desc) {\n                delete this.config.sortBy;\n                delete this.config.desc;\n            }\n            else {\n                this.config.desc = desc;\n                this.config.sortBy = property;\n            }\n            return;\n        }\n        else if (property !== this.config.sortBy) {\n            delete this.config.desc;\n            this.config.sortBy = property;\n        }\n        else if (this.config.desc) {\n            delete this.config.sortBy;\n        }\n        this.config.desc = this.config.desc === undefined ? desc || false : !this.config.desc;\n    }\n    /** Returns true if the given sort state is active. You can either just check for a property + desc flag */\n    isSorted(property, desc) {\n        if (typeof desc === 'undefined') {\n            return this.config.sortBy === property;\n        }\n        return this.config.sortBy === property && this.config.desc === desc;\n    }\n    /** Sorts with given sorting, using the Sorter */\n    toggleSort(property, desc) {\n        this.sortProperty(property, desc);\n        Sorter.sort(this.items, property, this.config.desc);\n        this.load(this.config);\n    }\n    /** Toggles selectMode of list config */\n    toggleSelectMode() {\n        this.config = Object.assign({}, this.config, {\n            selectMode: !this.config.selectMode,\n        });\n        this.change.next(this);\n    }\n    /** Returns an Array of all unique values of the given property */\n    groupBy(property) {\n        delete this.groups;\n        const page = this.pagination ? this.pagination.getPage() : 0;\n        if (!property || !this.config.fields || !this.config.fields[property] || !this.config.fields[property].group) {\n            this.groups = [\n                {\n                    page,\n                    sortBy: this.config.sortBy,\n                    desc: this.config.desc,\n                },\n            ];\n            return;\n        }\n        const groups = [];\n        this.page.forEach((item) => {\n            const value = item.group(property);\n            if (!groups.find((g) => g.value === value)) {\n                groups.push({\n                    value,\n                    page,\n                    property: this.config.sortBy,\n                    desc: this.config.desc,\n                });\n            }\n        });\n        this.groups = groups;\n    }\n    /** Item tracking for *ngFor. */\n    trackItem(index, item) {\n        return index;\n    }\n    /** Returns an array of all sortable fields */\n    sortableFields() {\n        return this.fields.filter((field) => field.sortable);\n    }\n    /** Returns an array of all sortable fields */\n    filterableFields() {\n        return this.fields.filter((field) => field.filterable);\n    }\n    /** Returns true if the given field index in the visible fields is higher than maxColumns.  */\n    isOverTheMax(field) {\n        return this.fields.filter((f) => !f.hideInList).indexOf(field) >= this.config.maxColumns;\n    }\n}\n\n/**\n * Extension of List that keeps track of selected items. It can keep track of items via identifier\n * property even if the object references are being replaced, e.g. when reloading a set if items.\n * It supports solo and multiple selection.\n */\nclass Selection extends List {\n    /** Adds item to selection. If solo is true, all other items will be removed. */\n    select(item, solo = this.config.solo) {\n        if (solo) {\n            this.removeAll();\n            this.add(item);\n        }\n        else {\n            this.add(item, true);\n        }\n    }\n    /** Returns the index of the given item or an item that has the same identifier or value. */\n    index(item) {\n        if (this.config.identifier) {\n            return this.items.indexOf(this.id(item.resolve(this.config.identifier)));\n        }\n        return this.items.indexOf(this.items.find((i) => i.resolve() === item.resolve()));\n    }\n    has(item) {\n        return super.has(item) || this.index(item) !== -1;\n    }\n    /** Toggle item in and out of selection.\n     * The solo property will change the behaviour like you would expect it to behave :) */\n    toggle(item, solo = this.config.solo, event = true) {\n        if (!item) {\n            console.warn('toggle malicious item', item);\n            return;\n        }\n        if (!this.has(item)) {\n            if (solo) {\n                return this.replaceWith([item], event);\n            }\n            this.add(item, event);\n        }\n        else if (solo) {\n            if (this.items.length > 1) {\n                // if multiple are selected => keep item\n                return this.replaceWith([item], event);\n            }\n            this.removeAll();\n        }\n        else {\n            this.remove(item, event);\n        }\n    }\n    /** Toggle multiple items. You can control if the items should be kept, flipped, or be kept unique*/\n    toggleAll(items, flip, keep) {\n        items = items || [];\n        // items = Array.isArray(items) ? items : [items];\n        if (!flip && !keep && this.hasAll(items)) {\n            this.removeAll(items);\n            return this;\n        }\n        items.forEach((item) => {\n            if (flip) {\n                this.toggle(item, this.config.solo, false);\n            }\n            else if (!this.hasAll(items)) {\n                this.add(item, true, false);\n            }\n        });\n        this.update.next(this);\n        return this;\n    }\n    /** Flips all items. */\n    flipAll(items) {\n        return this.toggleAll(items, true);\n    }\n    /** Returns an Array containing the current value. If an identifier is set, the array will consist of the identifier values,\n     * if not, it will resolve the item contents. */\n    getValue(solo = this.config.solo) {\n        const value = this.items.map((item) => (this.config.identifier ? item.id() : item.resolve()));\n        if (solo) {\n            return value.length ? value[0] : null;\n        }\n        return value;\n    }\n}\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Collection, Config, Field, Form, Item, List, Pagination, Selection, Sorter, sortBoolean, sortNumber, sortString };\n"]}