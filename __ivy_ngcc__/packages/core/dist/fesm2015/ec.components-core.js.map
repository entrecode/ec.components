{"version":3,"sources":["/Users/felix/entrecode/ec.components/packages/core/dist/fesm2015/ec.components-core.js"],"names":[],"mappings":"AAAA","file":"ec.components-core.js","sourcesContent":["import { Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * A Collection is a more sophisticated Array. It is fundamental for other classes like List.\n * @template T\n */\nclass Collection {\n    /**\n     * Constructs the collection with the given item Array (optional).\n     * \\@example\n     * ```typescript\n     *  const numbers = new Collection([1, 2, 3]);\n     * ```\n     * @param {?=} items\n     */\n    constructor(items = []) {\n        /**\n         * Subject that is nexted when the items update\n         */\n        this.update = new Subject();\n        /**\n         * Subject that is nexted when the items change\n         */\n        this.update$ = this.update.asObservable();\n        this.items = [];\n        items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => {\n            this.items.push(item);\n        }));\n    }\n    /**\n     * Returns the index of the given item\n     * @param {?} item\n     * @return {?}\n     */\n    index(item) {\n        return this.items.indexOf(item);\n    }\n    /**\n     * Checks if the Collection contains the given item.\n     * \\@example\n     * ```typescript\n     * numbers.has(2); //true\n     * ```\n     * @param {?} item\n     * @return {?}\n     */\n    has(item) {\n        return this.index(item) !== -1;\n    }\n    /**\n     * Checks if the Collection contains all given items.\n     * \\@example\n     * ```typescript\n     * numbers.has([1,2]); //true\n     * ```\n     * @param {?=} items\n     * @return {?}\n     */\n    hasAll(items = []) {\n        if (items === null) {\n            // console.warn('has all fail', this, items);\n            return false;\n        }\n        return items.reduce((/**\n         * @param {?} has\n         * @param {?} item\n         * @return {?}\n         */\n        (has, item) => {\n            return has && this.has(item);\n        }), true);\n    }\n    /**\n     * Adds the given item to the Collection. If the unique flag is set, the item will only be added\n     * if it is not contained.\n     * \\@example\n     * ```typescript\n     * numbers.add(4);\n     * ```\n     * @param {?} item\n     * @param {?=} unique\n     * @param {?=} event\n     * @return {?}\n     */\n    add(item, unique, event = true) {\n        if (unique && this.has(item)) {\n            return false;\n        }\n        this.items.push(item);\n        if (event) {\n            this.update.next(this);\n        }\n    }\n    /**\n     * Adds the given items to the Collection. If the unique flag is set, only items that are not\n     * contained will be added.\n     * \\@example\n     * ```typescript\n     * numbers.addAll([5, 6, 7]);\n     * ```\n     * @param {?=} items\n     * @param {?=} unique\n     * @param {?=} event\n     * @return {?}\n     */\n    addAll(items = [], unique = false, event = true) {\n        /** @type {?} */\n        const length = this.items.length;\n        items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => {\n            this.add(item, unique, false);\n        }));\n        if (this.items.length > length && event) {\n            this.update.next(this);\n        }\n    }\n    /**\n     * Removes the given item from the Collection.\n     * \\@example\n     * ```typescript\n     * numbers.remove(4);\n     * ```\n     * @param {?} item\n     * @param {?=} event\n     * @return {?}\n     */\n    remove(item, event = true) {\n        if (!this.has(item)) {\n            return false;\n        }\n        this.items.splice(this.index(item), 1);\n        if (event) {\n            this.update.next(this);\n        }\n    }\n    /**\n     * Removes all items from the Collection.\n     * \\@example\n     * ```typescript\n     * numbers.removeAll();\n     * ```\n     * @param {?=} items\n     * @param {?=} event\n     * @return {?}\n     */\n    removeAll(items, event = true) {\n        /** @type {?} */\n        const length = this.items.length;\n        if (items) {\n            items.forEach((/**\n             * @param {?} item\n             * @return {?}\n             */\n            (item) => {\n                this.remove(item, false);\n            }));\n        }\n        else {\n            this.items.length = 0;\n        }\n        if (this.items.length < length && event) {\n            this.update.next(this);\n        }\n    }\n    /**\n     * Toggles the item in and out of collection\n     * @param {?} item\n     * @param {?=} event\n     * @return {?}\n     */\n    toggle(item, event = true) {\n        if (this.has(item)) {\n            this.remove(item, event);\n        }\n        else {\n            this.add(item, event);\n        }\n    }\n    /**\n     * Replaces all current items with the given items.\n     * @param {?} items\n     * @param {?=} event\n     * @return {?}\n     */\n    replaceWith(items, event = true) {\n        if (this.items && this.items.length) {\n            this.removeAll(undefined, false);\n        }\n        if (items.length) {\n            this.addAll(items, false, false);\n        }\n        if (event) {\n            this.update.next(this);\n        }\n    }\n    /**\n     * Returns true if the collection is empty\n     * @return {?}\n     */\n    isEmpty() {\n        return this.items.length === 0;\n    }\n    /**\n     * Moves the given item to the given array index.\n     * @param {?} item\n     * @param {?} index\n     * @param {?=} event\n     * @return {?}\n     */\n    move(item, index, event = true) {\n        if (!this.has(item) || this.items.indexOf(item) === index) {\n            return;\n        }\n        this.items.splice(index, 0, this.items.splice(this.items.indexOf(item), 1)[0]);\n        if (event) {\n            this.update.next(this);\n        }\n    }\n}\nif (false) {\n    /**\n     * The items must all have the same type T.\n     * @type {?}\n     */\n    Collection.prototype.items;\n    /**\n     * Subject that is nexted when the items update\n     * @type {?}\n     * @protected\n     */\n    Collection.prototype.update;\n    /**\n     * Subject that is nexted when the items change\n     * @type {?}\n     */\n    Collection.prototype.update$;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** A Field acts as a property of an Item. It holds a single Property config. */\nclass Field {\n    /**\n     * A Field is constructed by assigning the given config and the property to itself\n     * @param {?} property\n     * @param {?} config\n     */\n    constructor(property, config) {\n        /**\n         * Possible Values e.g. in a select\n         */\n        this.values = [];\n        /**\n         * Class string\n         */\n        this.class = '';\n        if (config) {\n            Object.assign(this, config);\n        }\n        Object.assign(this, { property: property });\n        this.id = `${this.property}_${Date.now()}`;\n    }\n    /**\n     * Returns placeholder if any\n     * @return {?}\n     */\n    getPlaceholder() {\n        return this.placeholder || this.label || this.property;\n    }\n    /**\n     * Returns the fields label\n     * @return {?}\n     */\n    getLabel() {\n        if (this.label === false) {\n            return '';\n        }\n        return this.label || this.property;\n    }\n    /**\n     * Returns the view for the given occasion\n     * @param {?=} occasion\n     * @return {?}\n     */\n    getView(occasion) {\n        return this[occasion + 'View'] || this.view;\n    }\n    /**\n     * Returns the component for the given occasion\n     * @param {?=} occasion\n     * @return {?}\n     */\n    getComponent(occasion) {\n        return this[occasion + 'Component'];\n    }\n}\nif (false) {\n    /**\n     * Tells if the field is required in forms\n     * @type {?}\n     */\n    Field.prototype.required;\n    /**\n     * The name of the field's property\n     * @type {?}\n     */\n    Field.prototype.property;\n    /**\n     * If true, the field will not be visible anywhere\n     * @type {?}\n     */\n    Field.prototype.hidden;\n    /**\n     * If true, the field will autofocus after view init\n     * @type {?}\n     */\n    Field.prototype.autofocus;\n    /**\n     * The field's type\n     * @type {?}\n     */\n    Field.prototype.type;\n    /**\n     * The field's view\n     * @type {?}\n     */\n    Field.prototype.view;\n    /**\n     * Custom Validation function\n     * @type {?}\n     */\n    Field.prototype.validate;\n    /**\n     * Custom clean function to prepare for save\n     * @type {?}\n     */\n    Field.prototype.beforeSave;\n    /**\n     * Custom Component to display form input *\n     * @type {?}\n     */\n    Field.prototype.input;\n    /**\n     * Custom Component to display value *\n     * @type {?}\n     */\n    Field.prototype.output;\n    /**\n     * Placeholder in inputs\n     * @type {?}\n     */\n    Field.prototype.placeholder;\n    /**\n     * Label for Inputs. Defaults to property name. If false, the label is empty.\n     * @type {?}\n     */\n    Field.prototype.label;\n    /**\n     * The operator to use for filtering: exact, search, any etc.. see ec.sdk doc\n     * @type {?}\n     */\n    Field.prototype.filterOperator;\n    /**\n     * Defines the class for the filter pop, e.g. in list header. DEPRECATED\n     * @type {?}\n     */\n    Field.prototype.filterPopClass;\n    /**\n     * If true, the form input label will always be hidden\n     * @type {?}\n     */\n    Field.prototype.hideFormLabel;\n    /**\n     * If true, the form input label will be hidden if no value is set\n     * @type {?}\n     */\n    Field.prototype.hideFormLabelIfEmpty;\n    /**\n     * Wether or not the field should appear in default forms\n     * @type {?}\n     */\n    Field.prototype.form;\n    /**\n     * Possible Values e.g. in a select\n     * @type {?}\n     */\n    Field.prototype.values;\n    /**\n     * Class string\n     * @type {?}\n     */\n    Field.prototype.class;\n    /**\n     * id for form labels\n     * @type {?}\n     */\n    Field.prototype.id;\n    /**\n     * if false, the field will not be sortable in a list\n     * @type {?}\n     */\n    Field.prototype.sortable;\n    /**\n     * if false, the field will not be filterable in a list\n     * @type {?}\n     */\n    Field.prototype.filterable;\n    /**\n     * Defines the maximum of visible item (for tags view or similar). Defaults to 10\n     * @type {?}\n     */\n    Field.prototype.maxItems;\n    /**\n     * Icon name that should be associated with the field\n     * @type {?}\n     */\n    Field.prototype.icon;\n    /* Skipping unhandled member: [key: string]: any;*/\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The Root class for all Configurations.\n * @abstract\n */\nclass Config {\n    constructor() {\n        // TODO use Map !!!! (like simi did in EventEmitter.ts)\n        /**\n         * The config object.\n         */\n        this.config = {};\n    }\n    /**\n     * This method is a getter and setter for configurations. The key stands for the config (e.g. model).\n     * The property is a sub property if the config (e.g. fields => model.fields).\n     * If no config is given, the method just returns the configuration for the given property.\n     * If a config is given, the property config is merged via Object.assign.\n     * @param {?} key\n     * @param {?} property\n     * @param {?=} config\n     * @return {?}\n     */\n    configure(key, property, config) {\n        if (!this.config[key]) {\n            this.config[key] = {};\n        }\n        if (!config) {\n            return this.config[key][property];\n        }\n        if (!this.config[key][property]) {\n            this.config[key][property] = {};\n        }\n        Object.assign(this.config[key][property], config);\n        return this;\n    }\n}\nif (false) {\n    /**\n     * The config object.\n     * @type {?}\n     * @private\n     */\n    Config.prototype.config;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Configuration for list fields.\n * @record\n */\nfunction FieldConfig() { }\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Configuration for a FieldConfig property.\n * @record\n */\nfunction FieldConfigProperty() { }\nif (false) {\n    /**\n     * Property name\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.property;\n    /**\n     * Human readable field label. Defaults to property name. If false, the label is empty.\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.label;\n    /**\n     * Placeholder in inputs\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.placeholder;\n    /**\n     * Custom resolve transformation function.\n     * \\@param body The item body\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.resolve;\n    /**\n     * Custom resolve method to get the title, has priority over label property.\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.title;\n    /**\n     * Custom display transformation function.\n     * \\@param value The current property value\n     * \\@param field The field property name\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.display;\n    /**\n     * Custom copy transformation function.\n     * \\@param value The current property value\n     * \\@param field The field property name\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.copy;\n    /**\n     * Custom group transformation function. Its return value will be used for grouping.\n     * \\@param value The current property value\n     * \\@param field The field property name\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.group;\n    /**\n     * Custom sort transformation function. Its return value will be used for sorting.\n     * \\@param value The current property value\n     * \\@param field The field property name\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.sort;\n    /**\n     * Custom validation function. Its return value will be used for validation in a form.\n     * \\@param value The current property value\n     * \\@param field The field property name\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.validate;\n    /**\n     * Custom validation function. Its return value will be used for validation in a form.\n     * \\@param value The current property value\n     * \\@param field The field property name\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.filter;\n    /**\n     * The field's type (use FieldType.*)\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.type;\n    /**\n     * The model title of the entries/entry field\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.model;\n    /**\n     * The type of cell view. (e.g. tags, email etc..)\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.view;\n    /**\n     * The type of form input view. Defaults to type if not specified.\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.inputView;\n    /**\n     * Tells if the field should be hidden\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.hidden;\n    /**\n     * Tells if the field is required in forms\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.required;\n    /**\n     * The field's JSON schema.\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.schema;\n    /**\n     * Custom Component for input (forms)\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.input;\n    /**\n     * Custom Component for output (e.g. list cell)\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.output;\n    /**\n     * If true, the form input will be disabled when editing\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.readOnly;\n    /**\n     * If true, the property will always be disabled (like readOnly but also on create)\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.disabled;\n    /**\n     * If true, the property will be ignored when saving (filtered out from object of emitted object)\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.immutable;\n    /**\n     * if false, the field will not be filterable in a list\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.filterable;\n    /**\n     * The operator to use for filtering: exact, search, any etc.. see ec.sdk doc\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.filterOperator;\n    /**\n     * Defines the class for the filter pop, e.g. in list header. DEPRECATED\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.filterPopClass;\n    /**\n     * Transforms a string value from the url query to a value that is used for filtering.\n     * e.g. transforms \"A,B,C\" to ['A','B','C']\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.queryFilter;\n    /**\n     * if false, the field will not be sortable in a list\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.sortable;\n    /**\n     * if false, the field will not be visible in a list\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.list;\n    /**\n     * if false, the field will not be visible in a form\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.form;\n    /**\n     * If a prefill value is set, it will be used at creation in a form.\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.prefill;\n    /**\n     * Possible Values e.g. for a select\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.values;\n    /**\n     * Defines the maximum of visible item (for tags view or similar). Defaults to 10\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.maxItems;\n    /**\n     * Any other configuration properties\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.action;\n    /**\n     * Class string\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.class;\n    /**\n     * Icon name that should be associated with the field\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.icon;\n    /**\n     * Related identifier e.g. model name or assetGroupID\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.relation;\n    /**\n     * If true, the field will be filtered raw (no filterOperator magic)\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.rawFilter;\n    /**\n     * Columns that the field should inhabit in the form grid.\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.columns;\n    /**\n     * If true, the field wont be shown in the list column filter.\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.hideInColumnFilter;\n    /**\n     * If true, the field wont be shown in the form\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.hideInForm;\n    /**\n     * is fired when the value changes in a form\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.changed;\n    /**\n     * if true, the field will auto focus after view init\n     * @type {?|undefined}\n     */\n    FieldConfigProperty.prototype.autofocus;\n    /* Skipping unhandled member: [key: string]: any;*/\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An Item basically wraps an Object and provides a config with metadata and helper methods to access the object.\n * @template T\n */\nclass Item {\n    /**\n     * Each item is constructed with its body and an optional config.\n     * @param {?} body\n     * @param {?=} config\n     */\n    constructor(body, config = {}) {\n        this.body = body;\n        this.config = config || this.generateConfig();\n    }\n    /**\n     * Generates a config from the body by setting view to the properties type.\n     * @protected\n     * @return {?}\n     */\n    generateConfig() {\n        /** @type {?} */\n        const config = { fields: {} };\n        if (this.body === undefined) {\n            return config;\n        }\n        this.getProperties().forEach((/**\n         * @param {?} property\n         * @return {?}\n         */\n        (property) => {\n            config.fields[property] = {\n                view: typeof this.body[property],\n                type: typeof this.body[property],\n            };\n            if (config.fields[property].view === 'object' && Array.isArray(this.body[property])) {\n                config.fields[property].view = 'array';\n                config.fields[property].values = this.body[property];\n                // config.fields[property].solo = true;\n            }\n        }));\n        return config;\n    }\n    /**\n     * Returns the item's body\n     * @return {?}\n     */\n    getBody() {\n        return this.body;\n    }\n    /**\n     * Returns true if the body is defined and not null\n     * @return {?}\n     */\n    hasBody() {\n        return this.body !== undefined && this.body !== null;\n    }\n    /**\n     * deletes the item body\n     * @return {?}\n     */\n    clear() {\n        delete this.body;\n    }\n    /**\n     * Assigns the given config to the existing via Object.assign\n     * @param {?} config\n     * @return {?}\n     */\n    useConfig(config) {\n        this.config = ((/** @type {?} */ (Object))).assign(this.config, config);\n    }\n    /**\n     * Returns the item's config\n     * @return {?}\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Returns an Array of properties possessed by the body.\n     * @return {?}\n     */\n    getProperties() {\n        if (!this.body || typeof this.body !== 'object') {\n            if (typeof this.body !== 'object') {\n                return [this.config && this.config.title ? this.config.title : 'body'];\n            }\n            return [];\n        }\n        return Object.keys(this.body);\n    }\n    /**\n     * Returns the value of the the Item's identifier property.\n     * @return {?}\n     */\n    id() {\n        if (!this.config.identifier) {\n            throw new Error('cannot get id of item without identifier!');\n        }\n        return this.resolve(this.config.identifier);\n    }\n    /**\n     * Returns either the whole body (if no property is given) or the value of the given property.\n     * This method will traverse the body via the config.resolve function (if given).\n     * @param {?=} property\n     * @return {?}\n     */\n    resolve(property) {\n        if (!this.hasBody()) {\n            return;\n        }\n        if (typeof this.body !== 'object') {\n            return this.body;\n        }\n        if (!this.config) {\n            return property ? this.body[property] : this.body;\n        }\n        if (!property) {\n            if (this.config.resolve) {\n                return this.config.resolve(this.body, this);\n            }\n            return this.body;\n        }\n        if (this.config.fields && this.config.fields[property] && this.config.fields[property].resolve) {\n            return this.config.fields[property].resolve(this.body, this, property);\n        }\n        if (!this.config.resolve) {\n            return this.body[property];\n        }\n        /** @type {?} */\n        const v = this.config.resolve(this.body, this);\n        return v ? v[property] : null;\n    }\n    /**\n     * Resolves the given path on the item object. e.g. \"value.config.usePassword\" will resolve that object path, if existing.\n     * @param {?} path\n     * @return {?}\n     */\n    resolvePath(path) {\n        return getPath(this.body, path);\n    }\n    /**\n     * The main method for transformation functions like resolve, display and group.\n     * If you dont set the third parameter, the current item value will be used.\n     * The third parameter can be used to transform a value that is not yet possesed (e.g. to\n     * serialize)\n     * @param {?} action\n     * @param {?} property\n     * @param {?=} value\n     * @param {?=} defaultValue\n     * @return {?}\n     */\n    transform(action, property, value = this.resolve(property), defaultValue = this.resolve(property)) {\n        if (!this.hasBody()) {\n            return;\n        }\n        if (this.config.fields && this.config.fields[property] && this.config.fields[property][action]) {\n            return this.config.fields[property][action](value, this.body, property);\n        }\n        return defaultValue;\n    }\n    /**\n     * Returns the output of the config.group transformation function with the given property value.\n     * If no group function is set, it will just return the property value.\n     * @param {?} property\n     * @return {?}\n     */\n    group(property) {\n        return this.transform('group', property);\n    }\n    /**\n     * If no property given: Returns the output of the config.classes method or ''.\n     * If property given: Returns the output of the config.fields[property].classes method or ''\n     * @param {?=} property\n     * @return {?}\n     */\n    classes(property) {\n        if (property) {\n            return this.transform('classes', property, this.resolve(property), '') || '';\n        }\n        if (!this.config || !this.config.classes) {\n            return '';\n        }\n        return this.config.classes(this);\n    }\n    /**\n     * Returns the output of the config.display transformation function with the given property value.\n     * If no display function is set, it will just return the property value.\n     * @param {?=} property\n     * @return {?}\n     */\n    display(property) {\n        if (!property) {\n            return this.transform('display', this.config.label || this.getProperties()[0]); // Object.keys(this.resolve())[0]\n        }\n        return this.transform('display', property);\n    }\n    /**\n     * Transforms the given field's value for sorting\n     * @param {?} property\n     * @return {?}\n     */\n    sort(property) {\n        return this.transform('sort', property);\n    }\n    /**\n     * Returns value with all readOnly properties removed\n     * @param {?=} value\n     * @return {?}\n     */\n    pickWriteOnly(value = this.body) {\n        return ((/** @type {?} */ (Object))).assign({}, ...Object.keys(value)\n            .map((/**\n         * @param {?} property\n         * @return {?}\n         */\n        (property) => {\n            if (this.config.fields[property].readOnly) {\n                return;\n            }\n            return { [property]: value[property] };\n        }))\n            .filter((/**\n         * @param {?} v\n         * @return {?}\n         */\n        (v) => !!v)));\n    }\n    /**\n     * @param {?} property\n     * @return {?}\n     */\n    isImmutableProperty(property) {\n        if (this.config &&\n            this.config.fields &&\n            this.config.fields[property] &&\n            typeof this.config.fields[property].immutable === 'function') {\n            return this.config.fields[property].immutable(this);\n        }\n        return this.config.fields[property].immutable;\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    deleteImmutableProperties(value = this.body) {\n        Object.keys(this.config.fields).forEach((/**\n         * @param {?} property\n         * @return {?}\n         */\n        (property) => {\n            if (value.hasOwnProperty(property) && this.isImmutableProperty(property)) {\n                delete value[property];\n            }\n        }));\n    }\n    /**\n     * Transforms the given field's value for serialization when saving.\n     * @param {?} value\n     * @param {?=} put\n     * @return {?}\n     */\n    serialize(value, put = false) {\n        if (put) {\n            value = this.pickWriteOnly(value);\n        }\n        this.deleteImmutableProperties(value);\n        /** Run the remaining properties through serializers */\n        Object.keys(value).map((/**\n         * @param {?} property\n         * @return {?}\n         */\n        (property) => {\n            ((/** @type {?} */ (Object))).assign(value, {\n                [property]: this.transform('serialize', property, value[property]),\n            });\n        }));\n        return value;\n        /** Run the remaining properties through serializers */\n        /*return Object.keys(value).reduce((serialized, property) => {\n          return Object.assign(serialized, {\n            [property]: this.transform('serialize', property, value[property])\n          });\n        }, {});*/\n    }\n    /**\n     * Saves the given value. Run serializers before assigning the new value.\n     * @param {?=} value\n     * @return {?}\n     */\n    save(value = this.body) {\n        if (this.config.onSave) {\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            (resolve, reject) => {\n                try {\n                    Promise.resolve(this.config.onSave(this, value)).then((/**\n                     * @param {?} _value\n                     * @return {?}\n                     */\n                    (_value) => {\n                        this.body = _value;\n                        resolve(this);\n                    })).catch((/**\n                     * @param {?} error\n                     * @return {?}\n                     */\n                    error => reject(error)));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            }));\n        }\n        this.body = ((/** @type {?} */ (Object))).assign(this.resolve() || {}, value);\n        return Promise.resolve(this);\n    }\n    /**\n     * Action method that is meant to be called on a button click or similar.\n     * Calls the config#action method with the item and the property name\n     * @param {?} property\n     * @param {?} e\n     * @return {?}\n     */\n    action(property, e) {\n        e.preventDefault();\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n        if (this.config.fields[property].action) {\n            this.config.fields[property].action(this, property);\n        }\n    }\n}\nif (false) {\n    /**\n     * The value body of the item. This can be either a primitive value or an Object.\n     * @type {?}\n     */\n    Item.prototype.body;\n    /**\n     * The config of the item.\n     * @type {?}\n     */\n    Item.prototype.config;\n}\n/**\n * @param {?} o\n * @param {?} path\n * @return {?}\n */\nfunction getPath(o, path) {\n    /** @type {?} */\n    const p = path.split('.');\n    return p.length === 1 ? (o || {})[p[0]] : getPath((o || {})[p[0]], p.slice(1).join('.'));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The Form class is an Item with additional info about its properties (Fields).\n * @template T\n */\nclass Form extends Item {\n    /**\n     * The constructor will populate the fields array.\n     * If config.fields is set only the configured fields will be created.\n     * If not, all properties of the given body will be used as fields.\n     * @param {?} body\n     * @param {?=} config\n     */\n    constructor(body, config) {\n        super(body, config);\n        this.fields = [];\n        if (!this.config || !this.config.fields) {\n            return;\n        }\n        Object.keys(this.config.fields).forEach((/**\n         * @param {?} property\n         * @return {?}\n         */\n        (property) => {\n            this.fields.push(new Field(property, this.config.fields[property]));\n        }));\n    }\n    /**\n     * creates and adds a single field to the form\n     * @param {?} property\n     * @param {?} config\n     * @return {?}\n     */\n    createField(property, config) {\n        if (!config) {\n            return;\n        }\n        if (!property) {\n            return;\n        }\n        if (this.config.fields[property]) {\n            console.error('cannot create field \"', property, '\". Property name already taken.');\n            return;\n        }\n        this.config.fields[property] = config;\n        /** @type {?} */\n        const field = new Field(property, this.config.fields[property]);\n        this.fields = this.fields.concat([field]);\n        return field;\n    }\n    /**\n     * returns the field instance of the given property\n     * @param {?} property\n     * @return {?}\n     */\n    getField(property) {\n        return this.fields.find((/**\n         * @param {?} field\n         * @return {?}\n         */\n        (field) => field.property === property));\n    }\n    /**\n     * Returns the original value of the property, if any.\n     * @param {?} property\n     * @return {?}\n     */\n    getValue(property) {\n        if (!this.body && this.config.fields && this.config.fields[property]) {\n            // If the prefill is not a primitive, return a clone to stay pristine\n            if (Array.isArray(this.config.fields[property].prefill)) {\n                return this.config.fields[property].prefill.slice(0);\n            }\n            else if (typeof this.config.fields[property].prefill === 'object') {\n                return Object.assign({}, this.config.fields[property].prefill);\n            }\n            // if no body is present, the prefills are used\n            return this.config.fields[property].prefill;\n        }\n        else {\n            return this.resolve(property);\n        }\n    }\n    /**\n     * Returns true if the form is currently in edit mode (has a body set)\n     * @return {?}\n     */\n    isEditing() {\n        return !!this.getBody();\n    }\n    /**\n     * Returns true if the form is currently in create mode (has not a body set)\n     * @return {?}\n     */\n    isCreating() {\n        return !this.isEditing();\n    }\n}\nif (false) {\n    /**\n     * Array of fields. It will be populated automatically when the form is constructed.\n     * @type {?}\n     */\n    Form.prototype.fields;\n    /**\n     * The configuration of the form. It is an extension of ItemConfig.\n     * @type {?}\n     */\n    Form.prototype.config;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * FormConfig is an extension of ItemConfig.\n * @record\n * @template T\n */\nfunction FormConfig() { }\nif (false) {\n    /**\n     * If true, no submit button will be rendered.\n     * @type {?|undefined}\n     */\n    FormConfig.prototype.hideSubmitButton;\n    /**\n     * The label of the submit button\n     * @type {?|undefined}\n     */\n    FormConfig.prototype.submitButtonLabel;\n    /**\n     * If true, the column visibility filter will not be visible\n     * @type {?|undefined}\n     */\n    FormConfig.prototype.disableColumnFilter;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An ItemConfig describes an abstract entity with certain properties.\n * @record\n * @template T\n */\nfunction ItemConfig() { }\nif (false) {\n    /**\n     * For primitive values only: the title for the item\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.title;\n    /**\n     * The Property that is used to identify items from another (e.g. in a selection).\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.identifier;\n    /**\n     * Pattern of the identifier field. Is used e.g. in the searchbar\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.identifierPattern;\n    /**\n     * The Property that is used to display the item for humans\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.label;\n    /**\n     * The Items field Config\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.fields;\n    /**\n     * The type of the Item. It determines how it will be displayed in different contexts\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.type;\n    /**\n     * Custom resolve path function. It can be used e.g. to access subbranches of an Object.\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.resolve;\n    /**\n     * Contains the parent Instance which inhabits the item. This property is set programmatically and therefore meant to be readonly.\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.parent;\n    /**\n     * Callback that is invoked when the item is saved\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.onSave;\n    /**\n     * Callback that is invoked before the item is edited\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.onEdit;\n    /**\n     * This method can be used to set custom classes based on item contents. Used e.g. in list-items for row class\n     * @type {?|undefined}\n     */\n    ItemConfig.prototype.classes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * This class can be used to control the loading behaviour of external data.\n * @template T\n */\nclass Pagination {\n    /**\n     * You can init each Pagination instance with an optional config.\n     * If no config is provided, it will default to ```{page: 1, size: 25}```.\n     * @param {?=} config\n     * @param {?=} total\n     */\n    constructor(config, total) {\n        /**\n         * Subject for tracking changes.\n         */\n        this.change = new Subject();\n        /**\n         * Observable that is nexted when the pagination has changed.\n         */\n        this.change$ = this.change.asObservable();\n        this.config = { page: 1, size: 25 };\n        Object.assign(this.config, config);\n        Object.assign(this.config, {\n            availableSizes: Array.from(new Set([this.config.size]\n                .concat(this.config.availableSizes || [10, 25, 50, 100], [this.config.size])\n                .sort((/**\n             * @param {?} a\n             * @param {?} b\n             * @return {?}\n             */\n            (a, b) => a - b)))),\n        });\n        if (total) {\n            this.setTotal(total);\n        }\n    }\n    /**\n     * Retrieves the current page\n     * @return {?}\n     */\n    getPage() {\n        return this.config.page;\n    }\n    /**\n     * Retrieves the number of pages\n     * @return {?}\n     */\n    getPages() {\n        return this.pages ? this.pages.length : 0;\n    }\n    /**\n     * Loads the next page. Throws error if already on last page.\n     * @return {?}\n     */\n    next() {\n        if (this.isLast()) {\n            return; // already last page\n        }\n        this.config.page += 1;\n        this.load();\n    }\n    /**\n     * Loads the previous page. Throws error if already on first page.\n     * @return {?}\n     */\n    prev() {\n        if (this.isFirst()) {\n            return; // already first page\n        }\n        this.config.page -= 1;\n        this.load();\n    }\n    /**\n     * Sets the total number of items and calculcates the page count.\n     *\n     * @param {?} total\n     * @return {?}\n     */\n    setTotal(total) {\n        /* if (this.total !== total) {\n          this.change.next(this.config);\n        } */\n        this.total = total;\n        this.pages = new Array(Math.ceil(this.total / this.config.size));\n        if (this.config.page !== 1 && this.config.page > this.pages.length) {\n            this.config.page = this.pages.length || 1;\n            this.load();\n        }\n    }\n    /**\n     * Merges config and fires next on change\n     * @protected\n     * @param {?=} config\n     * @return {?}\n     */\n    load(config) {\n        if (config) {\n            Object.assign(this.config, config);\n        }\n        this.change.next(this.config);\n    }\n    /**\n     * Selects the given page number\n     * @param {?} page\n     * @param {?=} silent\n     * @return {?}\n     */\n    select(page, silent = false) {\n        if (page === this.config.page || silent) {\n            this.config.page = page;\n            return;\n        }\n        this.load({ page: page });\n    }\n    /**\n     * Loads the first Page\n     * @return {?}\n     */\n    first() {\n        this.load({ page: 1 });\n    }\n    /**\n     * Loads the last page\n     * @return {?}\n     */\n    last() {\n        if (!this.pages) {\n            throw new Error(`Cannot load last page without knowing the item count.\n        Call setTotal(itemCount) before loading.`);\n        }\n        this.load({ page: this.pages.length });\n    }\n    /**\n     * Returns true if the given page number is currently active.\n     * @param {?} page\n     * @return {?}\n     */\n    isActive(page) {\n        return this.config.page === page;\n    }\n    /**\n     * Returns true if the current page is the first one\n     * @return {?}\n     */\n    isFirst() {\n        return this.config.page === 1;\n    }\n    /**\n     * Returns true if the current page is the last one\n     * @return {?}\n     */\n    isLast() {\n        if (!this.pages) {\n            return true;\n        }\n        return this.config.page === this.pages.length;\n    }\n    /**\n     * slices a given array according to the current pagination state\n     * @param {?} items\n     * @return {?}\n     */\n    slice(items) {\n        return items.slice((this.config.page - 1) * this.config.size, this.config.page * this.config.size);\n    }\n    /**\n     * Returns an object with all relevant infos about the current state of pagination\n     * @return {?}\n     */\n    params() {\n        return {\n            page: this.getPage(),\n            pages: this.getPages(),\n            total: this.total,\n            from: (this.getPage() - 1) * this.config.size + 1,\n            to: Math.min(this.getPage() * this.config.size, this.total),\n            size: this.config.size,\n            availableSizes: this.config.availableSizes,\n        };\n    }\n    /**\n     * updates the size of the pages.\n     * @param {?} size\n     * @return {?}\n     */\n    updateSize(size) {\n        if (!size) {\n            return;\n        }\n        this.load({ size, page: 1 });\n    }\n}\nif (false) {\n    /**\n     * The total number of items that is being paginated. It can be changed via setTotal.\n     * @type {?}\n     * @protected\n     */\n    Pagination.prototype.total;\n    /**\n     * The pagination config\n     * @type {?}\n     * @protected\n     */\n    Pagination.prototype.config;\n    /**\n     * Array to iterate over the number of pages.\n     * @type {?}\n     */\n    Pagination.prototype.pages;\n    /**\n     * Subject for tracking changes.\n     * @type {?}\n     * @private\n     */\n    Pagination.prototype.change;\n    /**\n     * Observable that is nexted when the pagination has changed.\n     * @type {?}\n     */\n    Pagination.prototype.change$;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used for natural sorting of strings\n * @type {?}\n */\nconst collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\n/**\n * Sorts strings (naturally)\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sortString(a, b) {\n    return collator.compare(a, b);\n}\n/**\n * Sorts numbers\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sortNumber(a, b) {\n    return a - b;\n}\n/**\n * Sorts booleans\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sortBoolean(a, b) {\n    return a ? -1 : 1;\n}\n/**\n * The Sorter is a singleton that handles all kinds of sorting operations.\n * @abstract\n * @template T\n */\nclass Sorter {\n    /**\n     * Returns the sorting algorithm for the given item array.\n     * @private\n     * @param {?} items\n     * @param {?=} property\n     * @return {?}\n     */\n    static getAlgorithm(items, property) {\n        if (!items.length) {\n            return;\n        }\n        if (property && !items.reduce((/**\n         * @param {?} has\n         * @param {?} item\n         * @return {?}\n         */\n        (has, item) => has && item.sort(property) !== undefined), true)) {\n            console.warn('cannot sort property \"' + property + '\" because not all items have that property', items);\n            return;\n        }\n        /** @type {?} */\n        const types = items\n            .map((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => typeof item.sort(property)))\n            .filter((/**\n         * @param {?} item\n         * @param {?} index\n         * @param {?} _items\n         * @return {?}\n         */\n        (item, index, _items) => _items.indexOf(item) === index));\n        if (types.length > 1) {\n            console.warn('cannot sort items because they contain multiple types:', types);\n            return;\n        }\n        if (!this.sortType[types[0]]) {\n            console.warn('cannot sort items because no algorithm was found for type', types[0]);\n            return;\n        }\n        return this.sortType[types[0]];\n    }\n    /**\n     * Sorts a given Array of items after a given property.\n     * @param {?} items Array of arbitrary content.\n     * @param {?=} property Optional property to sort after (For Objects)\n     * @param {?=} desc Optional Flag that will reverse sort the result (descending).\n     * @return {?}\n     */\n    static sort(items, property, desc) {\n        /** @type {?} */\n        const algorithm = this.getAlgorithm(items, property);\n        if (!algorithm) {\n            return;\n        }\n        items.sort((/**\n         * @param {?} a\n         * @param {?} b\n         * @return {?}\n         */\n        (a, b) => {\n            if (!property) {\n                return algorithm(a.resolve(), b.resolve());\n            }\n            return algorithm(a.sort(property), b.sort(property));\n        }));\n        if (desc) {\n            items.reverse();\n        }\n    }\n}\n/**\n * Contains sorting methods for different value types.\n */\nSorter.sortType = {\n    string: sortString,\n    number: sortNumber,\n    boolean: sortBoolean,\n};\nif (false) {\n    /**\n     * Contains sorting methods for different value types.\n     * @type {?}\n     */\n    Sorter.sortType;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * A more sophisticated Collection of Objects with arbitrary content.\n * It comes with features like resolve functions, identifiers, display formatting and sorting.\n * @template T\n */\nclass List extends Collection {\n    /**\n     * Constructs the List. Populates the items and instantiates the fields.\n     * @param {?=} values\n     * @param {?=} config\n     * @param {?=} pagination\n     */\n    constructor(values, config = {}, pagination) {\n        super([]);\n        /**\n         * Current Value Groups (Different Unique Values).\n         */\n        this.groups = [];\n        /**\n         * The items of the current page\n         */\n        this.page = [];\n        /**\n         * Subject that should be nexted when loading is finished\n         */\n        this.change = new Subject();\n        /**\n         * Observable that is nexted when the list has changed.\n         */\n        this.change$ = this.change.asObservable();\n        if (values) {\n            super.addAll(values.map((/**\n             * @param {?} value\n             * @return {?}\n             */\n            (value) => new Item(value, Object.assign({}, config)))), false, false);\n        }\n        this.config = Object.assign({ page: 1, maxColumns: 8 }, config || {});\n        this.fields = this.getFields();\n        this.hideOverflowFields();\n        this.pagination = pagination || new Pagination(this.config, this.items.length);\n        this.change$.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.pagination.select(this.config.page || 1, true);\n        }));\n        if (!pagination) {\n            // load if no custom pagination was given\n            this.pagination.change$.pipe(debounceTime(200)).subscribe((/**\n             * @param {?} _config\n             * @return {?}\n             */\n            (_config) => this.load(_config)));\n            this.load();\n        }\n    }\n    /**\n     * Getter for items, calls transform\n     * @return {?}\n     */\n    get display() {\n        if (!this.config || !this.config.display) {\n            return this.items;\n        }\n        return this.config.display(this.items);\n    }\n    /**\n     * Loads the list page with the given config or, if none given, uses the current config.\n     * Reapplies grouping (if any) and calls the change Subject.\n     * @param {?=} config\n     * @return {?}\n     */\n    load(config) {\n        if (config) {\n            Object.assign(this.config, config);\n        }\n        this.page = this.pagination.slice(this.items);\n        this.groupBy(this.config.sortBy);\n        this.change.next(this);\n    }\n    /**\n     * Adds the given item to the list and assigns the list config to the item\n     * @param {?} item\n     * @param {?=} unique\n     * @param {?=} event\n     * @return {?}\n     */\n    add(item, unique, event = true) {\n        item.useConfig(this.config);\n        return super.add(item, unique, event);\n    }\n    /**\n     * Distills Array of item properties. Either uses keys of config.fields or parses the item\n     * properties directly.\n     * @protected\n     * @return {?}\n     */\n    getFields() {\n        if (this.config && this.config.fields) {\n            return Object.keys(this.config.fields)\n                .filter((/**\n             * @param {?} key\n             * @return {?}\n             */\n            (key) => this.config.fields[key].list !== false))\n                .map((/**\n             * @param {?} field\n             * @return {?}\n             */\n            (field) => new Field(field, this.config.fields[field])));\n        }\n        /** @type {?} */\n        const fields = [];\n        this.items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => {\n            item.getProperties().forEach((/**\n             * @param {?} property\n             * @return {?}\n             */\n            (property) => {\n                if (!fields.find((/**\n                 * @param {?} f\n                 * @return {?}\n                 */\n                (f) => f.property === property))) {\n                    fields.push(new Field(property, { type: typeof item.resolve(property) }));\n                }\n            }));\n        }));\n        return fields;\n    }\n    /**\n     * @param {?} field\n     * @return {?}\n     */\n    toggleVisibility(field) {\n        field.hideInList = !field.hideInList;\n        this.change.next(this);\n    }\n    /**\n     * Sets all fields that exceed the maxColumns to hidden\n     * @protected\n     * @return {?}\n     */\n    hideOverflowFields() {\n        if (this.config && this.config.maxColumns) {\n            this.fields\n                .filter((/**\n             * @param {?} f\n             * @return {?}\n             */\n            (f) => !f.hideInList))\n                .forEach((/**\n             * @param {?} field\n             * @param {?} index\n             * @return {?}\n             */\n            (field, index) => {\n                if (index >= this.config.maxColumns && field.hideInList === undefined) {\n                    field.hideInList = true;\n                }\n            }));\n        }\n    }\n    /**\n     * Resolves the item with the given Array index or identifier (if configured)\n     * @param {?} identifier\n     * @return {?}\n     */\n    id(identifier) {\n        if (identifier === undefined) {\n            throw new Error(`cannot get item with identifier \"${identifier}\"`);\n        }\n        return (this.items.find((/**\n         * @param {?} item\n         * @param {?} key\n         * @return {?}\n         */\n        (item, key) => {\n            if (!item.config.identifier) {\n                return false;\n            }\n            return item.id() === identifier;\n        })) || this.items[identifier]);\n    }\n    /**\n     * Filters the list after the given property and value\n     * @param {?} property\n     * @param {?=} value\n     * @param {?=} operator\n     * @return {?}\n     */\n    filter(property, value = '', operator = 'exact') {\n        this.config.filter = { [property]: value };\n        if (value === null) {\n            this.load();\n            return;\n            // this.page = [].concat(this.items);\n        }\n        // TODO find way to filter with pagination and without loosing filtered out items\n        this.page = this.items\n            .filter((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => {\n            return item\n                .resolve(property)\n                .toLowerCase()\n                .includes(value.toLowerCase()); // TODO: better filter\n        }))\n            .slice(0, this.config.size || 100);\n    }\n    /**\n     * @param {?=} filterOptions\n     * @return {?}\n     */\n    setFilter(filterOptions = {}) {\n        if (!this.isFiltered(null, filterOptions) && !this.isFiltered()) {\n            return;\n        }\n        if (this.isEmptyFilter(filterOptions)) {\n            return this.clearFilter();\n        }\n        filterOptions = Object.keys(filterOptions).reduce((/**\n         * @param {?} filtered\n         * @param {?} key\n         * @return {?}\n         */\n        (filtered, key) => {\n            if (this.isEmptyFilter(filterOptions[key])) {\n                delete filtered[key];\n            }\n            return filtered;\n        }), filterOptions);\n        this.load({\n            page: 1,\n            filter: filterOptions,\n        });\n    }\n    /**\n     * Clears the filter for given property or all properties if none given.\n     * @param {?=} property\n     * @return {?}\n     */\n    clearFilter(property) {\n        if (property) {\n            return this.filter(property, null);\n        }\n        this.load({\n            page: 1,\n            filter: {},\n        });\n    }\n    /**\n     * Helper function. Returns true if the given query value is empty (also recognizes empty array)\n     * @param {?} query\n     * @return {?}\n     */\n    isEmptyFilter(query) {\n        return (query === '' ||\n            query === null ||\n            query === undefined ||\n            (Array.isArray(query) && !query.length) ||\n            (typeof query === 'object' && Object.keys(query).length === 0));\n    }\n    /**\n     * Returns true if the given property has a filter set. If no property is given it returns true when no property has a filter.\n     * @param {?=} property\n     * @param {?=} filterOptions\n     * @return {?}\n     */\n    isFiltered(property, filterOptions = this.config.filter) {\n        if (!filterOptions) {\n            return false;\n        }\n        if (!property) {\n            return Object.keys(filterOptions).filter((/**\n             * @param {?} key\n             * @return {?}\n             */\n            (key) => !this.isEmptyFilter(filterOptions[key]))).length > 0;\n        }\n        return !this.isEmptyFilter(filterOptions[property]);\n    }\n    /**\n     * Returns the filter\n     * @param {?=} property\n     * @param {?=} filterOptions\n     * @return {?}\n     */\n    getFilterValue(property, filterOptions = this.config.filter) {\n        if (!property) {\n            property = this.config.label;\n        }\n        if (!filterOptions || !property) {\n            return undefined;\n        }\n        return filterOptions[property];\n    }\n    /**\n     * Changes the config's sort variables to reflect the given sorting\n     * @protected\n     * @param {?} property\n     * @param {?=} desc\n     * @return {?}\n     */\n    sortProperty(property, desc) {\n        if (desc !== undefined) {\n            if (this.config.desc === desc) {\n                delete this.config.sortBy;\n                delete this.config.desc;\n            }\n            else {\n                this.config.desc = desc;\n                this.config.sortBy = property;\n            }\n            return;\n        }\n        else if (property !== this.config.sortBy) {\n            delete this.config.desc;\n            this.config.sortBy = property;\n        }\n        else if (this.config.desc) {\n            delete this.config.sortBy;\n        }\n        this.config.desc = this.config.desc === undefined ? desc || false : !this.config.desc;\n    }\n    /**\n     * Returns true if the given sort state is active. You can either just check for a property + desc flag\n     * @param {?} property\n     * @param {?=} desc\n     * @return {?}\n     */\n    isSorted(property, desc) {\n        if (typeof desc === 'undefined') {\n            return this.config.sortBy === property;\n        }\n        return this.config.sortBy === property && this.config.desc === desc;\n    }\n    /**\n     * Sorts with given sorting, using the Sorter\n     * @param {?} property\n     * @param {?=} desc\n     * @return {?}\n     */\n    toggleSort(property, desc) {\n        this.sortProperty(property, desc);\n        Sorter.sort(this.items, property, this.config.desc);\n        this.load(this.config);\n    }\n    /**\n     * Toggles selectMode of list config\n     * @return {?}\n     */\n    toggleSelectMode() {\n        this.config = Object.assign({}, this.config, {\n            selectMode: !this.config.selectMode,\n        });\n        this.change.next(this);\n    }\n    /**\n     * Returns an Array of all unique values of the given property\n     * @param {?} property\n     * @return {?}\n     */\n    groupBy(property) {\n        delete this.groups;\n        /** @type {?} */\n        const page = this.pagination ? this.pagination.getPage() : 0;\n        if (!property || !this.config.fields || !this.config.fields[property] || !this.config.fields[property].group) {\n            this.groups = [\n                {\n                    page,\n                    sortBy: this.config.sortBy,\n                    desc: this.config.desc,\n                },\n            ];\n            return;\n        }\n        /** @type {?} */\n        const groups = [];\n        this.page.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => {\n            /** @type {?} */\n            const value = item.group(property);\n            if (!groups.find((/**\n             * @param {?} g\n             * @return {?}\n             */\n            (g) => g.value === value))) {\n                groups.push({\n                    value,\n                    page,\n                    property: this.config.sortBy,\n                    desc: this.config.desc,\n                });\n            }\n        }));\n        this.groups = groups;\n    }\n    /**\n     * Item tracking for *ngFor.\n     * @param {?} index\n     * @param {?} item\n     * @return {?}\n     */\n    trackItem(index, item) {\n        return index;\n    }\n    /**\n     * Returns an array of all sortable fields\n     * @return {?}\n     */\n    sortableFields() {\n        return this.fields.filter((/**\n         * @param {?} field\n         * @return {?}\n         */\n        (field) => field.sortable));\n    }\n    /**\n     * Returns an array of all sortable fields\n     * @return {?}\n     */\n    filterableFields() {\n        return this.fields.filter((/**\n         * @param {?} field\n         * @return {?}\n         */\n        (field) => field.filterable));\n    }\n    /**\n     * Returns true if the given field index in the visible fields is higher than maxColumns.\n     * @param {?} field\n     * @return {?}\n     */\n    isOverTheMax(field) {\n        return this.fields.filter((/**\n         * @param {?} f\n         * @return {?}\n         */\n        (f) => !f.hideInList)).indexOf(field) >= this.config.maxColumns;\n    }\n}\nif (false) {\n    /**\n     * Array of Properties that are relevant for each item. The fields are populated on construction\n     * via getFields method.\n     * @type {?}\n     */\n    List.prototype.fields;\n    /**\n     * The List Configuration, click on ListConfig for details. Can be given an optional ListConfig.\n     * @type {?}\n     */\n    List.prototype.config;\n    /**\n     * Current Value Groups (Different Unique Values).\n     * @type {?}\n     */\n    List.prototype.groups;\n    /**\n     * The list's pagination (Optional)\n     * @type {?}\n     */\n    List.prototype.pagination;\n    /**\n     * The items of the current page\n     * @type {?}\n     */\n    List.prototype.page;\n    /**\n     * Subject that should be nexted when loading is finished\n     * @type {?}\n     * @protected\n     */\n    List.prototype.change;\n    /**\n     * Observable that is nexted when the list has changed.\n     * @type {?}\n     */\n    List.prototype.change$;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n *  Configuration for List Classes.\n *\n * @record\n * @template T\n */\nfunction ListConfig() { }\nif (false) {\n    /**\n     * For lists with primitive values only: the title of the list header\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.title;\n    /**\n     * The property name that is sorted after\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.sortBy;\n    /**\n     * Array of properties that is sorted after, experimental...\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.sort;\n    /**\n     * If set to true, the sorting will be descending\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.desc;\n    /**\n     * If true, the list will show its checkboxes and will select on column click.\n     * The columnClicked output will be ignored as long selectMode is active\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.selectMode;\n    /**\n     * If true, no select dropdown will be shown on ec-select\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.disableSearchbar;\n    /**\n     * If true, the list will have no header.\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.disableHeader;\n    /**\n     * If true, the header will also be shown when the list is empty. Defaults to false\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.alwaysShowHeader;\n    /**\n     * If true, no dropdown will be shown for a select\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.disableDropdown;\n    /**\n     * If true, removal of items wont be possible (select)\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.disableRemove;\n    /**\n     * If true, no column filter will be shown in the list header\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.disableColumnFilter;\n    /**\n     * If true, select items cannot be dragged\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.disableDrag;\n    /**\n     * If true, the default pagination will not be visible.\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.hidePagination;\n    /**\n     * The current active page\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.page;\n    /**\n     * The number of items per page\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.size;\n    /**\n     * The available sizes. If not set, the size cannot be changed\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.availableSizes;\n    /**\n     * Should the selection be solo?\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.solo;\n    /**\n     * tells the list to show only items that match the filter\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.filter;\n    /**\n     * a query that will be turned in to a filter\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.query;\n    /**\n     * Maximal visible columns. Defaults to 8\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.maxColumns;\n    /**\n     * how many columns should the pop have?\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.popColumns;\n    /**\n     * If true, the list will automatically load on change\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.autoload;\n    /**\n     * The key that should store the lists config in the local storage.\n     * If set, the key will be populated on config changes.\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.storageKey;\n    /**\n     * Transforms the Items before they are displayed, e.g. to apply a filter for the view *\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.display;\n    /**\n     * If set, a filter input for the given field property will be shown by default\n     * @type {?|undefined}\n     */\n    ListConfig.prototype.defaultFilter;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Extension of List that keeps track of selected items. It can keep track of items via identifier\n * property even if the object references are being replaced, e.g. when reloading a set if items.\n * It supports solo and multiple selection.\n * @template T\n */\nclass Selection extends List {\n    /**\n     * Adds item to selection. If solo is true, all other items will be removed.\n     * @param {?} item\n     * @param {?=} solo\n     * @return {?}\n     */\n    select(item, solo = this.config.solo) {\n        if (solo) {\n            this.removeAll();\n            this.add(item);\n        }\n        else {\n            this.add(item, true);\n        }\n    }\n    /**\n     * Returns the index of the given item or an item that has the same identifier or value.\n     * @param {?} item\n     * @return {?}\n     */\n    index(item) {\n        if (this.config.identifier) {\n            return this.items.indexOf(this.id(item.resolve(this.config.identifier)));\n        }\n        return this.items.indexOf(this.items.find((/**\n         * @param {?} i\n         * @return {?}\n         */\n        (i) => i.resolve() === item.resolve())));\n    }\n    /**\n     * @param {?} item\n     * @return {?}\n     */\n    has(item) {\n        return super.has(item) || this.index(item) !== -1;\n    }\n    /**\n     * Toggle item in and out of selection.\n     * The solo property will change the behaviour like you would expect it to behave :)\n     * @param {?} item\n     * @param {?=} solo\n     * @param {?=} event\n     * @return {?}\n     */\n    toggle(item, solo = this.config.solo, event = true) {\n        if (!item) {\n            console.warn('toggle malicious item', item);\n            return;\n        }\n        if (!this.has(item)) {\n            if (solo) {\n                return this.replaceWith([item], event);\n            }\n            this.add(item, event);\n        }\n        else if (solo) {\n            if (this.items.length > 1) {\n                // if multiple are selected => keep item\n                return this.replaceWith([item], event);\n            }\n            this.removeAll();\n        }\n        else {\n            this.remove(item, event);\n        }\n    }\n    /**\n     * Toggle multiple items. You can control if the items should be kept, flipped, or be kept unique\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items\n     * @param {?=} flip\n     * @param {?=} keep\n     * @return {THIS}\n     */\n    toggleAll(items, flip, keep) {\n        items = items || [];\n        // items = Array.isArray(items) ? items : [items];\n        if (!flip && !keep && (/** @type {?} */ (this)).hasAll(items)) {\n            (/** @type {?} */ (this)).removeAll(items);\n            return (/** @type {?} */ (this));\n        }\n        items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => {\n            if (flip) {\n                (/** @type {?} */ (this)).toggle(item, (/** @type {?} */ (this)).config.solo, false);\n            }\n            else if (!(/** @type {?} */ (this)).hasAll(items)) {\n                (/** @type {?} */ (this)).add(item, true, false);\n            }\n        }));\n        (/** @type {?} */ (this)).update.next((/** @type {?} */ (this)));\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Flips all items.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items\n     * @return {THIS}\n     */\n    flipAll(items) {\n        return (/** @type {?} */ (this)).toggleAll(items, true);\n    }\n    /**\n     * Returns an Array containing the current value. If an identifier is set, the array will consist of the identifier values,\n     * if not, it will resolve the item contents.\n     * @param {?=} solo\n     * @return {?}\n     */\n    getValue(solo = this.config.solo) {\n        /** @type {?} */\n        const value = this.items.map((/**\n         * @param {?} item\n         * @return {?}\n         */\n        (item) => (this.config.identifier ? item.id() : item.resolve())));\n        if (solo) {\n            return value.length ? value[0] : null;\n        }\n        return value;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { Collection, Config, Field, Form, Item, List, Pagination, Selection, Sorter, sortBoolean, sortNumber, sortString };\n"]}