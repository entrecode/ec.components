{"version":3,"sources":["/Users/felix/entrecode/ec.components/packages/calendar/dist/fesm2015/ec.components-calendar.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DA8PE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BA4D2B,AAK1B;;;;;;;;;;;;;;;;;;;;;;sFAWD;;;;;;;;qDAQmD,AAM9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sFAoErB;;;;;;;;uDAQqD,AAMlC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2PA8GnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDA8BoD,AAYnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+FA6BD;;;;2BAIyB,AAIxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAqBiB","file":"ec.components-calendar.js","sourcesContent":["import { __decorate, __metadata, __param } from 'tslib';\nimport { EventEmitter, Inject, Input, Output, Component, ViewChild, forwardRef, Pipe, NgModule } from '@angular/core';\nimport moment from 'moment-es6';\nimport { debounceTime } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport { FormControl, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\n/** Displays the days of a month in a calendarish table. */\nlet MonthComponent = class MonthComponent {\n    /* public symbol: SymbolService */\n    constructor(defaultMonthFormat) {\n        this.defaultMonthFormat = defaultMonthFormat;\n        this.todayMoment = moment();\n        /** The color of days that are inside the timespan */\n        this.spancolor = '#ccc';\n        /** If true, the timespan start cannot be dragged */\n        this.disableDragStart = false;\n        /** If true, the timespan end cannot be dragged */\n        this.disableDragEnd = false;\n        /** If true, cannot drag anywhere to select a span (can still drag start and end, if not disabled too) */\n        this.disableDragAnywhere = false;\n        /** If true, no dragging can be done at all (other drag flags will be ignored) */\n        this.disableDrag = false;\n        /** Format for month in header */\n        this.monthFormat = 'MMMM YYYY';\n        /** Emits when the selected day changes. */\n        this.dayClicked = new EventEmitter();\n        /** Changed Timespan selection */\n        this.spanChanged = new EventEmitter();\n        this.changeSpan = new Subject();\n        /* this.monthFormat = this.symbol.resolve('moment.format.month') || this.monthFormat; */\n        this.monthFormat = this.defaultMonthFormat || this.monthFormat;\n        this.changeSpan\n            .asObservable()\n            .pipe(debounceTime(500))\n            .subscribe((timespan) => {\n            this.spanChanged.emit(this.timespan);\n        });\n    }\n    isDraggable(day) {\n        return !this.disabled &&\n            !this.disableDrag &&\n            ((!this.disableDragAnywhere || this.isInTimeSpan(day.date)) ||\n                ((day.first && !this.disableDragStart) || day.last && !this.disableDragEnd));\n    }\n    dragOverDay(day, e) {\n        if (!this.dragged) {\n            return;\n        }\n        this.selected = null;\n        /*  if (day.date.isSame(this.dragged.date)) {\n           return;\n         } */\n        if (!day || !this.isSelectable(day.date)) {\n            return;\n        }\n        let newTimespan;\n        if (this.move) {\n            const moved = day.date.diff(this.dragged.date, 'days');\n            newTimespan = [this.timespan[0].clone().add(moved, 'days'), this.timespan[1].clone().add(moved, 'days')];\n            this.dragged = day;\n        }\n        else {\n            newTimespan = [].concat(this.timespan);\n            newTimespan[this.dragged.first ? 0 : 1] = day.date.clone();\n        }\n        if (this.selectSpan && (newTimespan[0].isBefore(this.selectSpan[0].startOf('day')) || newTimespan[1].isAfter(this.selectSpan[1].endOf('day')))) {\n            return;\n        }\n        if (newTimespan[0].isSame(this.timespan[0]) && newTimespan[1].isSame(this.timespan[1])) {\n            // nothing changes => no need to rerender\n            return;\n        }\n        if (newTimespan[0].isAfter(newTimespan[1])) {\n            this.dragged.first = !this.dragged.first;\n            this.dragged.last = !this.dragged.last;\n            newTimespan.reverse();\n        }\n        this.timespan = newTimespan;\n        // this.changeSpan.next(this.timespan);\n        this.setDate();\n        /* if (this.cells[0] === day || this.cells[this.cells.length - 1] === day) {\n          // change month if dragging to edge\n          this.setDate(day.date.clone().subtract(1, 'days'));\n        } else {\n          this.setDate();\n        } */\n        /* this.cells = this.getMonth(this.date, 'current'); */\n    }\n    isInTimeSpan(date) {\n        return this.timespan && date.isBetween(this.timespan[0], this.timespan[1], 'days', '][');\n    }\n    dragStart(day, e) {\n        if (this.disabled || !this.isDraggable(day)) {\n            return;\n        }\n        e.preventDefault();\n        this.dragged = day;\n        this.move = false;\n        if (!day.first && !day.last) {\n            if (this.isInTimeSpan(day.date)) {\n                this.move = true;\n                return;\n            }\n            this.timespan = [day.date, day.date];\n            this.setDate();\n        }\n    }\n    mouseUp(day, e) {\n        if (!this.dragged) {\n            return;\n        }\n        delete this.dragged;\n        this.changeSpan.next(this.timespan);\n        e.preventDefault();\n    }\n    mouseOver(day, e) {\n        if (!this.dragged || this.dragged === day) {\n            return;\n        }\n        e.preventDefault();\n        this.dragOverDay(day, e);\n    }\n    getDayColor(_moment) {\n        if (this.colors && this.colors[_moment.toISOString()]) {\n            return this.colors[_moment.toISOString()];\n        }\n    }\n    getDayHeat(_moment) {\n        if (this.heatmap && this.heatmap[_moment.toISOString()]) {\n            return this.heatmap[_moment.toISOString()];\n        }\n    }\n    /** Initializes the calendar. */\n    ngOnInit() {\n        this.setDate();\n    }\n    /** When changing the date or selected input, the calendar will update its view to display the month containing it. */\n    ngOnChanges(change) {\n        if (change.selected) {\n            this.setDate(this.selected);\n            return;\n        }\n        else if (change.date) {\n            this.setDate(this.date);\n        }\n        else if (change.timespan || change.selectSpan) {\n            this.setDate();\n        }\n        if (change.colors || change.heatmap) {\n            this.cells = this.getMonth(this.date.clone(), 'current');\n        }\n    }\n    /** Returns days of current month */\n    getMonth(day = moment(), type) {\n        const begin = day\n            .clone()\n            .startOf('month')\n            .startOf('week'); // .subtract(weeksbefore * 7, 'days');\n        return new Array(42)\n            .fill(0)\n            .map((d, index) => begin.clone().add(index, 'days'))\n            .map((date, index) => {\n            const isStart = this.timespan &&\n                date\n                    .clone()\n                    .startOf('day')\n                    .isSame(this.timespan[0].clone().startOf('day'));\n            const isEnd = this.timespan &&\n                date\n                    .clone()\n                    .startOf('day')\n                    .isSame(this.timespan[1].clone().startOf('day'));\n            return {\n                index,\n                date,\n                type: date.format('MM YYYY') === day.format('MM YYYY') ? 'current' : 'other',\n                active: this.timespan && date.isBetween(this.timespan[0], this.timespan[1], 'days', '[]'),\n                first: isStart,\n                last: isEnd,\n                selectable: this.isSelectable(date),\n                inside: this.isInTimeSpan(date),\n                color: this.getDayColor(date),\n                heat: this.getDayHeat(date),\n                format: date.format('DD'),\n                today: moment()\n                    .startOf('day')\n                    .diff(date, 'days') === 0,\n            };\n        });\n    }\n    /** Sets the calendars viewed date to the given moment's month. Renders always 42 cells to keep the layout consistent. */\n    setDate(date = this.selected || this.date) {\n        if (date && date !== this.date) {\n            this.date = date.clone();\n        }\n        if (!date) {\n            this.date = this.selectSpan ? this.selectSpan[1].clone() : moment();\n        }\n        setTimeout(() => {\n            this.formatted = this.date.format(this.monthFormat);\n            this.cells = this.getMonth(this.date.clone(), 'current');\n        });\n    }\n    /** Selects the day of the given moment. */\n    selectDay(_moment, emit = true) {\n        if (this.disabled || !this.isSelectable(_moment)) {\n            return;\n        }\n        if (!this.disableDragAnywhere) {\n            this.timespan = [_moment, _moment];\n            this.spanChanged.emit(this.timespan);\n        } /* else if (!this.isInTimeSpan(_moment)) {\n          if (_moment.isBefore(this.timespan[0])) {\n            this.timespan = [_moment, this.timespan[1]];\n          } else if (_moment.isAfter(this.timespan[1])) {\n            this.timespan = [this.timespan[0], _moment];\n          }\n          this.spanChanged.emit(this.timespan);\n        } */\n        else if (!this.timespan) {\n            this.selected = _moment;\n        }\n        this.setDate(_moment);\n        if (emit) {\n            this.dayClicked.emit(_moment);\n        }\n    }\n    /** Clears the current selected date*/\n    clearSelection() {\n        delete this.selected;\n    }\n    /** Returns true if the given moment is currently selected (on a day basis) */\n    isSelected(_moment) {\n        if (!this.selected) {\n            return;\n        }\n        return this.selected.startOf('day').diff(_moment, 'days') === 0;\n    }\n    isSelectable(date, span = 'days') {\n        return !this.selectSpan || date.isBetween(this.selectSpan[0], this.selectSpan[1], span, '[]');\n    }\n    canAlter(value, span) {\n        var _a;\n        const newDate = (_a = this.date) === null || _a === void 0 ? void 0 : _a.clone().add(value, span);\n        return this.isSelectable(newDate, 'months');\n    }\n    /** Updates the viewed date to reflect the given relative changes. */\n    alter(value, span) {\n        if (!this.canAlter(value, span)) {\n            return;\n        }\n        this.setDate(this.date.clone().add(value, span));\n    }\n    /** Sets the current viewed date to today. */\n    today() {\n        this.setDate(moment());\n    }\n    /** Sets the current selected date to today. */\n    setToday() {\n        this.selectDay(moment());\n    }\n};\nMonthComponent.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: ['moment.format.month',] }] }\n];\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"selected\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"colors\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"heatmap\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Array)\n], MonthComponent.prototype, \"timespan\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Array)\n], MonthComponent.prototype, \"selectSpan\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"date\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"spancolor\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"disableDragStart\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"disableDragEnd\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"disableDragAnywhere\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"disableDrag\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], MonthComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], MonthComponent.prototype, \"dayClicked\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], MonthComponent.prototype, \"spanChanged\", void 0);\nMonthComponent = __decorate([\n    Component({\n        selector: 'ec-month',\n        template: \"<ul class=\\\"ec-calendar-days\\\">\\n  <li\\n    *ngFor=\\\"let day of cells; let i = index\\\"\\n    [class.is-active]=\\\"day.active\\\"\\n    [class.is-last]=\\\"day.last\\\"\\n    [class.is-first]=\\\"day.first\\\"\\n    [class.is-inside-timespan]=\\\"day.inside && !day.last && !day.first\\\"\\n    [class.is-draggable]=\\\"isDraggable(day)\\\"\\n    [class.is-disabled]=\\\"day.disabled\\\"\\n    [class.heat-none]=\\\"day.heat === 0\\\"\\n    [class.heat-low]=\\\"day.heat > 0 && day.heat < 30\\\"\\n    [class.heat-medium]=\\\"day.heat >= 30 && day.heat < 70\\\"\\n    [class.heat-high]=\\\"day.heat >= 70 && day.heat < 90\\\"\\n    [class.heat-extreme]=\\\"day.heat >= 90\\\"\\n    [draggable]=\\\"isDraggable(day)\\\"\\n    (dragstart)=\\\"dragStart(day, $event)\\\"\\n    (click)=\\\"selectDay(day.date)\\\"\\n    (mouseover)=\\\"mouseOver(day, $event)\\\"\\n    (mouseup)=\\\"mouseUp(day, $event)\\\"\\n  >\\n    <div\\n      class=\\\"ec-calendar-day\\\"\\n      [style.background-color]=\\\"day.color\\\"\\n      [class.is-other]=\\\"day.type !== 'current'\\\"\\n      [class.is-not-selectable]=\\\"!day.selectable\\\"\\n      [class.is-today]=\\\"day.today\\\"\\n      [class.is-selected]=\\\"isSelected(day.date)\\\"\\n    >\\n      {{ day.class || day.format }}\\n    </div>\\n  </li>\\n</ul>\\n\"\n    }),\n    __param(0, Inject('moment.format.month')),\n    __metadata(\"design:paramtypes\", [Object])\n], MonthComponent);\n\nlet DaterangeComponent = class DaterangeComponent extends MonthComponent {\n    constructor() {\n        super(...arguments);\n        /** The date that should be displayed at start. */\n        this.date = moment();\n    }\n    ngOnInit() { }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], DaterangeComponent.prototype, \"date\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Array)\n], DaterangeComponent.prototype, \"timespan\", void 0);\nDaterangeComponent = __decorate([\n    Component({\n        selector: 'ec-daterange',\n        template: \"<div class=\\\"ec-daterange\\\">\\n    <ec-calendar (spanChanged)=\\\"spanChanged.emit($event)\\\" [timespan]=\\\"timespan\\\" [date]=\\\"date\\\" class=\\\"ec-daterange-start\\\"></ec-calendar>\\n</div>\"\n    })\n], DaterangeComponent);\n\n/**\n * Displays a heatmap\n * <example-url>https://components.entrecode.de/ui/datetime?e=1</example-url>\n */\nlet HeatmapComponent = class HeatmapComponent extends MonthComponent {\n    constructor() {\n        super(...arguments);\n        /** Array of timestamps that should be turned into a heatmap */\n        this.timestamps = [];\n        /** If true, the timespan of the first given timestamps will be kept, no matter what follows */\n        this.keepTimespan = false;\n    }\n    ngOnInit() {\n        this.updateHeatmap();\n    }\n    /** When changing the date or selected input, the calendar will update its view to display the month containing it. */\n    ngOnChanges(change) {\n        if (change.timestamps && this.timestamps) {\n            const sorted = this.timestamps.sort((a, b) => {\n                return moment(a).isAfter(moment(b)) ? -1 : 1;\n            });\n            this.timespan =\n                this.keepTimespan && this.timespan ? this.timespan : [moment(sorted[sorted.length - 1]), moment(sorted[0])];\n            this.stats = this.statsInfo();\n            this.updateHeatmap();\n        }\n    }\n    toShade(count, max = 100, digits = 2) {\n        if (max === 0) {\n            return 0;\n        }\n        const grain = Math.pow(10, digits);\n        return (Math.floor((count / max) * grain) / grain) * 100;\n    }\n    getHeatMap(timestamps) {\n        const dates = timestamps\n            .map((timestamp) => moment(timestamp)\n            .startOf('day')\n            .toISOString())\n            .reduce((counts, date) => Object.assign(counts, {\n            [date]: ++counts[date] || 0,\n        }), {});\n        const max = dates[Object.keys(dates).sort((a, b) => (dates[a] > dates[b] ? -1 : 1))[0]];\n        return Object.keys(dates).reduce((classes, date) => {\n            return Object.assign(classes, {\n                [date]: Math.floor((dates[date] / max) * 100),\n            });\n        }, {});\n    }\n    /** Returns json with additional infos about the timestamps */\n    statsInfo(digits = 3) {\n        const dayspan = this.timespan[1].diff(this.timespan[0], 'days');\n        return {\n            timespan: this.timespan,\n            count: this.timestamps.length,\n            dayspan,\n            density: Math.floor((this.timestamps.length / dayspan) * Math.pow(10, digits)) / Math.pow(10, digits),\n        };\n    }\n    updateHeatmap() {\n        if (!this.timestamps) {\n            this.heatmap = [];\n            return;\n        }\n        this.heatmap = this.getHeatMap(this.timestamps);\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Array)\n], HeatmapComponent.prototype, \"timestamps\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], HeatmapComponent.prototype, \"keepTimespan\", void 0);\nHeatmapComponent = __decorate([\n    Component({\n        selector: 'ec-heatmap',\n        template: \"<div class=\\\"ec-heatmap\\\">\\n  <ec-calendar\\n    (spanChanged)=\\\"spanChanged.emit($event)\\\"\\n    [heatmap]=\\\"heatmap\\\"\\n    [timespan]=\\\"timespan\\\"\\n    [date]=\\\"date\\\"\\n    [disabled]=\\\"disabled\\\"\\n    [disableDrag]=\\\"disableDrag\\\"\\n    [disableDragAnywhere]=\\\"disableDragAnywhere\\\"\\n    [disableDragStart]=\\\"disableDragStart\\\"\\n    [disableDragEnd]=\\\"disableDragEnd\\\"\\n    [selectSpan]=\\\"selectSpan\\\"\\n  ></ec-calendar>\\n</div>\\n\"\n    })\n], HeatmapComponent);\n\nvar CalendarComponent_1;\n/** Input for a datetime.\n *\n * <example-url>https://components.entrecode.de/ui/datetime?e=1</example-url>\n */\nlet CalendarComponent = CalendarComponent_1 = class CalendarComponent extends MonthComponent {\n    /** The constructor gets the weekdays for the calendar header and instantiates the allowed input patterns.*/\n    constructor(defaultDateFormat, defaultTimeFormat, defaultMonthFormat /* public symbol: SymbolService */) {\n        /* super(symbol); */\n        super(defaultMonthFormat);\n        this.defaultDateFormat = defaultDateFormat;\n        this.defaultTimeFormat = defaultTimeFormat;\n        this.defaultMonthFormat = defaultMonthFormat;\n        /** Output that emits when the value changes */\n        this.changed = new EventEmitter();\n        /** The current value */\n        this.value = '';\n        /** The current value of the input */\n        this.inputValue = '';\n        /** The input's placeholder */\n        this.placeholder = '';\n        /** Allowed date input patterns. The first one will be standard. */\n        this.patterns = ['DD.MM.YYYY', 'DD.MM', 'DD.MM.YY', 'MM-DD-YYYY', 'YYYY-MM-DD', 'YYYY-MM-DD'];\n        /** Sets the input format of the time */\n        this.timeFormat = 'HH:mm';\n        /** Change propagation for ControlValueAccessor */\n        this.propagateChange = (_) => { };\n        // pattern localization\n        /* this.patterns = this.symbol.resolve('moment.format.date') ?\n        // [defaultDateFormatthis.symbol.resolve('moment.format.date')] : this.patterns; */\n        this.patterns = defaultDateFormat ? [defaultDateFormat] : this.patterns;\n        /* this.timeFormat = this.symbol.resolve('moment.format.time') || this.timeFormat; */\n        this.timeFormat = defaultTimeFormat || this.timeFormat;\n        this.weekdays = moment.weekdaysMin(true);\n        if (!this.disableTime) {\n            this.patterns = this.patterns\n                .map((pattern) => {\n                return pattern + ' ' + this.timeFormat;\n            })\n                .concat(this.patterns);\n        }\n    }\n    getPattern(_moment) {\n        const format = _moment.creationData().format;\n        if (this.patterns.indexOf(format) !== -1) {\n            return format;\n        }\n        return this.patterns[0];\n    }\n    /** Updates the value with the given moment and propagates the change. */\n    select(selected) {\n        if (this.disabled) {\n            console.warn('cannot select date: calendar is set to disabled=true');\n            return;\n        }\n        if (this.value && selected.hour() === 0 && selected.minute() === 0) {\n            const previous = moment(this.value, this.patterns, true);\n            selected.hour(previous.hour());\n            selected.minute(previous.minute());\n        }\n        this.value = selected.format(this.getPattern(selected));\n        this.inputValue = this.value;\n        this.setValue(selected.toISOString() || 'invalid');\n    }\n    /** Called upon input value change by the user. */\n    input(value) {\n        this.value = value;\n        const typed = moment(value, [...this.patterns, moment.ISO_8601], true);\n        if (typed.isValid()) {\n            this.grid.selectDay(typed, false);\n            this.setValue(typed.toISOString());\n        }\n        else if (value === '') {\n            this.grid.clearSelection();\n            this.setValue(null);\n        }\n        else {\n            this.setValue(typed.toISOString() || 'invalid');\n        }\n    }\n    /** called when the value should be changed from inside the component. calls propagateChange and emits the change output */\n    setValue(value) {\n        this.propagateChange(value);\n        this.changed.emit(value);\n    }\n    /** Selects the given Date when the model changes. */\n    writeValue(value) {\n        if (!value) {\n            return '';\n        }\n        const date = moment(value);\n        if (!date.isValid()) {\n            console.warn('written model value is not valid', date);\n            return;\n        }\n        this.value = date.format(this.patterns[0]) || '';\n        this.inputValue = this.value;\n        this.grid.selectDay(moment(value));\n    }\n    /** registerOnChange implementation of ControlValueAccessor */\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    /** registerOnTouched implementation of ControlValueAccessor */\n    registerOnTouched() { }\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n};\nCalendarComponent.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: ['moment.format.date',] }] },\n    { type: undefined, decorators: [{ type: Inject, args: ['moment.format.time',] }] },\n    { type: undefined, decorators: [{ type: Inject, args: ['moment.format.month',] }] }\n];\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], CalendarComponent.prototype, \"changed\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", FormControl)\n], CalendarComponent.prototype, \"formControl\", void 0);\n__decorate([\n    ViewChild(MonthComponent, { static: true }),\n    __metadata(\"design:type\", MonthComponent)\n], CalendarComponent.prototype, \"grid\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], CalendarComponent.prototype, \"placeholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], CalendarComponent.prototype, \"disabled\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], CalendarComponent.prototype, \"disableTime\", void 0);\nCalendarComponent = CalendarComponent_1 = __decorate([\n    Component({\n        selector: 'ec-calendar',\n        template: \"<svg\\n  aria-hidden=\\\"true\\\"\\n  style=\\\"position: absolute; width: 0; height: 0; overflow: hidden;\\\"\\n  version=\\\"1.1\\\"\\n  xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n  xlink=\\\"http://www.w3.org/1999/xlink\\\"\\n>\\n  <defs>\\n    <symbol id=\\\"arrowhead-left\\\" viewBox=\\\"0 0 24 24\\\">\\n      <title>arrowhead-left</title>\\n      <path\\n        d=\\\"M13.829 19c-0.292 0-0.582-0.127-0.78-0.373l-4.828-6c-0.298-0.371-0.294-0.901 0.011-1.267l5-6c0.353-0.424 0.984-0.481 1.409-0.128s0.481 0.984 0.127 1.408l-4.475 5.371 4.315 5.362c0.346 0.43 0.278 1.060-0.153 1.406-0.184 0.149-0.406 0.221-0.626 0.221z\\\"\\n      ></path>\\n    </symbol>\\n    <symbol id=\\\"arrowhead-right\\\" viewBox=\\\"0 0 24 24\\\">\\n      <title>arrowhead-right</title>\\n      <path\\n        d=\\\"M9.999 19c-0.226 0-0.453-0.076-0.64-0.232-0.424-0.353-0.481-0.984-0.128-1.408l4.476-5.371-4.315-5.362c-0.346-0.43-0.278-1.060 0.152-1.406 0.431-0.346 1.060-0.278 1.407 0.152l4.828 6c0.298 0.371 0.294 0.901-0.011 1.267l-5 6c-0.198 0.237-0.482 0.36-0.769 0.36z\\\"\\n      ></path>\\n    </symbol>\\n    <symbol id=\\\"today\\\" viewBox=\\\"0 0 24 24\\\">\\n      <title>today</title>\\n      <path d=\\\"M16 12c0 2.209-1.791 4-4 4s-4-1.791-4-4c0-2.209 1.791-4 4-4s4 1.791 4 4z\\\"></path>\\n    </symbol>\\n  </defs>\\n</svg>\\n<style>\\n  .ixo {\\n    display: inline-block;\\n    width: 1em;\\n    height: 1em;\\n    stroke-width: 0;\\n    stroke: currentColor;\\n    fill: currentColor;\\n  }\\n</style>\\n<div class=\\\"ec-calendar\\\">\\n  <nav class=\\\"ec-calendar-controls\\\">\\n    <a\\n      (click)=\\\"grid.alter(-1, 'months')\\\"\\n      class=\\\"btn btn_clear btn_square ec-calendar-controls__prev\\\"\\n      [class.is-disabled]=\\\"!grid.canAlter(-1, 'month')\\\"\\n    >\\n      <svg class=\\\"ixo\\\">\\n        <use xlink:href=\\\"#arrowhead-left\\\"></use>\\n      </svg>\\n    </a>\\n    <div class=\\\"ec-calendar-title\\\">{{ grid.formatted }}</div>\\n    <a\\n      *ngIf=\\\"isSelectable(todayMoment)\\\"\\n      (click)=\\\"grid.setToday()\\\"\\n      class=\\\"btn btn_clear btn_square ec-calendar-controls__current\\\"\\n    >\\n      <svg class=\\\"ixo\\\">\\n        <use xlink:href=\\\"#today\\\"></use>\\n      </svg>\\n    </a>\\n    <a\\n      (click)=\\\"grid.alter(1, 'months')\\\"\\n      class=\\\"btn btn_clear btn_square ec-calendar-controls__next\\\"\\n      [class.is-disabled]=\\\"!grid.canAlter(1, 'month')\\\"\\n    >\\n      <svg class=\\\"ixo\\\">\\n        <use xlink:href=\\\"#arrowhead-right\\\"></use>\\n      </svg>\\n    </a>\\n  </nav>\\n  <div class=\\\"ec-calendar-month \\\">\\n    <ul class=\\\"ec-calendar-weekdays \\\">\\n      <li *ngFor=\\\"let weekday of weekdays\\\">\\n        {{ weekday }}\\n      </li>\\n    </ul>\\n    <ec-month\\n      [disabled]=\\\"disabled\\\"\\n      [disableDrag]=\\\"disableDrag\\\"\\n      [disableDragAnywhere]=\\\"disableDragAnywhere\\\"\\n      [disableDragStart]=\\\"disableDragStart\\\"\\n      [disableDragEnd]=\\\"disableDragEnd\\\"\\n      (spanChanged)=\\\"spanChanged.emit($event)\\\"\\n      [selectSpan]=\\\"selectSpan\\\"\\n      [timespan]=\\\"timespan\\\"\\n      [heatmap]=\\\"heatmap\\\"\\n      [date]=\\\"date\\\"\\n      (dayClicked)=\\\"select($event)\\\"\\n      #grid\\n    ></ec-month>\\n  </div>\\n</div>\\n\",\n        providers: [\n            {\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => CalendarComponent_1),\n                multi: true,\n            },\n        ]\n    }),\n    __param(0, Inject('moment.format.date')),\n    __param(1, Inject('moment.format.time')),\n    __param(2, Inject('moment.format.month')),\n    __metadata(\"design:paramtypes\", [Object, Object, Object])\n], CalendarComponent);\n\n/* import { SymbolService } from '../../symbol/symbol.service'; */\n/** The GroupPipe filters an array of Item instances by a given property value.\n * It is meant to be used to get only the items with the exact same value. */\nlet DatetimePipe = class DatetimePipe {\n    constructor(dateFormat /* private symbol: SymbolService */) {\n        this.dateFormat = dateFormat;\n    }\n    transform(value, pattern = this.dateFormat /* this.symbol.resolve('moment.format.date') */, raw) {\n        if (!value) {\n            return '';\n        }\n        if (raw) {\n            console.log('raw', raw);\n        }\n        const typed = moment(value, pattern, true);\n        if (!typed.isValid()) {\n            return '';\n        }\n        if (Array.isArray(pattern)) {\n            pattern = pattern[0];\n        }\n        return moment(value).format(pattern);\n    }\n};\nDatetimePipe.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: ['moment.format.date',] }] }\n];\nDatetimePipe = __decorate([\n    Pipe({\n        name: 'datetime',\n    }),\n    __param(0, Inject('moment.format.date')),\n    __metadata(\"design:paramtypes\", [Object])\n], DatetimePipe);\n\nvar CalendarModule_1;\n/** This Module contains all calendar related components */\nlet CalendarModule = CalendarModule_1 = class CalendarModule {\n    static forRoot(formats) {\n        return {\n            ngModule: CalendarModule_1,\n            providers: [\n                {\n                    provide: 'moment.format.date',\n                    useValue: formats.date,\n                },\n                {\n                    provide: 'moment.format.time',\n                    useValue: formats.time,\n                },\n                {\n                    provide: 'moment.format.month',\n                    useValue: formats.month,\n                },\n            ],\n        };\n    }\n};\nCalendarModule = CalendarModule_1 = __decorate([\n    NgModule({\n        imports: [CommonModule],\n        exports: [DatetimePipe, CalendarComponent, HeatmapComponent, DaterangeComponent, MonthComponent],\n        declarations: [DatetimePipe, CalendarComponent, HeatmapComponent, DaterangeComponent, MonthComponent],\n        providers: [\n            {\n                provide: 'moment.format.date',\n                useValue: 'DD.MM.YYYY',\n            },\n            {\n                provide: 'moment.format.time',\n                useValue: 'HH:mm',\n            },\n            {\n                provide: 'moment.format.month',\n                useValue: 'MMMM YYYY',\n            },\n        ],\n    })\n], CalendarModule);\n\n/*\n * Public API Surface of calendar\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CalendarComponent, CalendarModule, DaterangeComponent, DatetimePipe, HeatmapComponent, MonthComponent };\n"]}